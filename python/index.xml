<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on Chiyo&#39;s blog</title>
    <link>https://moematsuda-ai.github.io/watanuki/python/index.html</link>
    <description>Recent content in Python on Chiyo&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Tue, 22 Nov 2022 08:12:48 +0000</lastBuildDate><atom:link href="https://moematsuda-ai.github.io/watanuki/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Torch</title>
      <link>https://moematsuda-ai.github.io/watanuki/python/torch/index.html</link>
      <pubDate>Tue, 22 Nov 2022 08:12:48 +0000</pubDate>
      <guid>https://moematsuda-ai.github.io/watanuki/python/torch/index.html</guid>
      <description>About calcuration of gradient How not to calculate gradient Use no_grad For example;
with torch.no_grad(): y = x*2 We can use as decorator
@torch.no_grad() def doubler(x): return x*2 Use .detach() -&amp;gt; ? Use .reaquires_grad -&amp;gt; ? reference Pytorchの「.detach()」と「with no_grad():」と「.requires_grad = False」の違い PyTorchの新しい推論モードについて </description>
    </item>
    <item>
      <title>Pickle</title>
      <link>https://moematsuda-ai.github.io/watanuki/python/pickle/index.html</link>
      <pubDate>Tue, 22 Nov 2022 08:12:12 +0000</pubDate>
      <guid>https://moematsuda-ai.github.io/watanuki/python/pickle/index.html</guid>
      <description>pickleの使用方法 Saving with openでの保存、読み込み with open(&amp;#34;filename.pkl&amp;#34;, &amp;#34;wb&amp;#34;) as f: pickle.dump(data, f) with open(&amp;#34;filename.pkl&amp;#34;, &amp;#34;rb&amp;#34;) as f: hoge = pickle.load(f) pandasでの保存、読み込み import pandas as pd pd.to_pickle(data, &amp;#34;filename.pkl&amp;#34;) hoge = pd.read_pickle(&amp;#34;filename.pkl&amp;#34;) joblib(?)での保存、読み込み joblib.dump(data, &amp;#34;filename.jb&amp;#34;, compress=3) hoge = joblib.load(&amp;#34;filename.jb&amp;#34;) </description>
    </item>
    <item>
      <title>Useful Functions in Numpy</title>
      <link>https://moematsuda-ai.github.io/watanuki/python/numpy_function/index.html</link>
      <pubDate>Tue, 22 Nov 2022 08:11:04 +0000</pubDate>
      <guid>https://moematsuda-ai.github.io/watanuki/python/numpy_function/index.html</guid>
      <description>Pythonが動的に解釈を行う言語であるという性質上、for文などのループを繰り返す場合には低速性が特に顕著に現れる。したがって一般的にPythonではfor文を多様せず、numpyやPandas等の高速なライブラリを利用する。
Numpyは多くの操作に対して静的型付きでコンパイルされた関数への便利なインターフェースを提供している。 これはベクトル化操作として知られており、配列に対して操作を実行するだけで、各要素に適用される。
Numpyのベクトル化演算は、ufunc(ユニバーサル関数)を使用して実装されており、このufuncの主な目的は、Numpyの各要素に対して繰り返し演算を素早くすることにある。
便利なNumpy関数 以下ではimport numpy as npとしてnumpyをimportしているものとする
npはnumpy, shapeは配列の形状, arrは任意の配列を示す
Numpyで実装されている演算子とその等価なufunc
関数 等価なufunc 説明 + np.add(arr, x) 加算(arrやxの順序はとわない。また配列同士、変数同士でも演算可) - np.subtract(arr, x) 減算（以下同文） - np.negative(arr) 単行マイナス * np.multiply(以下略) 乗算 / np.divide 除算 // np.floor_divide 整数除算(小数点以下切り捨て) ** np.power べき乗 % np.mod 剰余 Numpyで実装されている比較演算子とその等価なufunc
演算子 等価なufunc == np.equal != np.not_equal &amp;lt; np.less &amp;lt;= np.less_equal &amp;gt; np.greater &amp;gt;= np.greater_equal Numpyのufunc
関数 説明 引数 arr.reshape(shape) 配列arrを指定したshapeの型に変形 shape arr[np.axis] 新しく次元を追加 &amp;mdash; np.concatenate([arr1, arr2, arr3]) 次元の同じ複数の配列を結合 連結する配列(タプルまたは配列のリスト), axis=0で第1の軸方向に結合（デフォルト）, axis=1で第2の軸方向 np.</description>
    </item>
    <item>
      <title>Numpy</title>
      <link>https://moematsuda-ai.github.io/watanuki/python/numpy/index.html</link>
      <pubDate>Tue, 22 Nov 2022 08:10:50 +0000</pubDate>
      <guid>https://moematsuda-ai.github.io/watanuki/python/numpy/index.html</guid>
      <description>1. Numpy　概要 Pythonにはデータの集合を扱うための様々なデータ型がある。
標準で用意されているもの 名前 例 リスト(list) L=[&amp;quot;kiwi&amp;quot;, &amp;quot;banana&amp;quot;, &amp;quot;apple&amp;quot;] インデックス番号付き集合 タプル(tuple) T=(&amp;quot;kiwi&amp;quot;, &amp;quot;banana&amp;quot;, &amp;quot;apple&amp;quot;) インデックス番号付き集合(代入不可) 辞書(dict) D={&amp;quot;kiwi&amp;quot;:3, &amp;quot;banana&amp;quot;:2, &amp;quot;apple&amp;quot;:3} インデックス番号無し (key,value) 対応表 集合(set) S={&amp;quot;kiwi&amp;quot;, &amp;quot;banana&amp;quot;, &amp;quot;apple&amp;quot;} インデックス番号無し集合 拡張モジュールを利用するもの。 名前 例 numpy.ndarray N=np.array([1,2,3]) 数値計算用の多次元配列（ブロードキャストを提供する高速で目盛り効率の良い多次元配列が実装されている。 ） pandas.Series s=pd.Series([280,198],index=[&#39;tomato&#39;,&#39;banana&#39;]) 行に名前がある1次元配列 pandas.DataFrame df=pd.DataFrame([[&#39;tomato&#39;,280],[&#39;banana&#39;, 198]], columns=[&#39;name&#39;,&#39;price&#39;]) 列や行に名前がある2次元配列 Numpyとは？ NumpyとはN次元配列(N-dimensional array, ndarray)を定義し、ベクトルや行列をはじめとする数値計算を行うためのモジュールであり、以下のような特徴を持つ。
C言語で記述されているため高速処理可能 高速に動作し、呼び出しにループ記法を必要としない標準的な数学関数 Numpyモジュールで生成する配列の型名はnumpy.ndarray ディスクへの読み書きに加え、メモリマップファイル機能を提供する入出力 行列計算、乱数生成、フーリエ変換の各機能 C, C++, Fortran へのインタフェース(C言語呼び出しのAPIがあることで、NumpyからC言語で書かれた外部ライブラリへデータを渡したり、逆に外部ライブラリの計算結果をNumpyに戻し、ndarrayとして扱うこともできる。) ※Numpyはデータ演算の基盤を提供するが、実際に構造化データや表形式データを分析する場面ではpandasを用いるのが一般的
モジュールの読み込み NumPyモジュールは慣例的にnpの名称で利用される。
import numpy as np print(np.__version__) Numpyのマニュアル参照 np? Numpyの関数とメソッド 配列ndarrayの生成や，複数の配列に対する操作(結合等)には, NumPyの関数を使う すで生成されているndarrayオブジェクトの加工には，ndarrayに対するメソッドを使う ※　以下では，NumPyの関数とメソッドの説明の際に，両者を以下のように書いて区別する</description>
    </item>
    <item>
      <title>Matplotlib</title>
      <link>https://moematsuda-ai.github.io/watanuki/python/matplotlib/index.html</link>
      <pubDate>Tue, 22 Nov 2022 08:10:00 +0000</pubDate>
      <guid>https://moematsuda-ai.github.io/watanuki/python/matplotlib/index.html</guid>
      <description>Matplotlibとは？ グラフやそれ以外の2次元の形式で行うデータの可視化に用いるライブラリ。
出版に適したグラフを作るのに非常に適しており、IPythonとうまく統合されているためIPythonとmatplotlibはデータのグラフ化や探索を容易に行えるインタラクティブな環境を提供している。 ウィンドウに表示されているツールバーからプロットの特定の領域をズームしたり、プロットで表示されれる範囲を変更することができる。
Matplotlibにおけるグラフを書く方法 pypplot インターフェース
単純なグラフの描画には便利 オズジェクト指向インターフェース
サブグラフを用意するなど細かい指定をするときに便利 Pyplotインターフェース plt.から始まる命令で簡単にグラフをかける 単純なグラフ作成向け Numpyモジュールの使用 数学関数の描画には、ベクトル・行列演算用のNumPyモジュールを使うと便利。Numpyはリストと似ているが数値データの処理に特化したメソッドが色々用意されている。
(例)
import numpy as np step=0.1 time=np.arange(0,20+step,step) # 0以上20+step未満の数値をstep刻みで生成 sint=np.sin(time) # timeの各要素に対するsin関数の値をリスト化 cost=np.cos(time) # timeの各要素に対するsin関数の値をリスト化 plt.figure(figsize=(8, 4)) plt.plot(time, sint, label=&amp;#34;sin t&amp;#34;) # x,y軸データから，labelは省略可 plt.plot(time, cost, label=&amp;#34;cos t&amp;#34;) # pltにcos関数のグラフも追加 # ラベル等の追加 plt.xlabel(&amp;#34;time [s]&amp;#34;) # pltにx軸ラベル追加 plt.ylabel(&amp;#34;y&amp;#34;) # pltにy軸ラベル追加 plt.legend(loc=&amp;#34;upper right&amp;#34;) # pltに凡例(plot()の引数に指定したlabel)を追加 # plt.savefig(&amp;#39;figure.png&amp;#39;) # グラフを保存したい場合。拡張子に応じてpng,jpg,pdf等の出力可能 plt.show() # グラフオブジェクトpltの描画 オブジェクト指向インターフェース グラフの見栄え等に関する細かい設定をすることができる。 コンテナと呼ばれるオブジェクトの中に、描画パーツやさらにコンテナを配置していくことでグラフを作成する。 matplotlibのオブジェクト指向インターフェースの基本構造 matplotlibのオブジェクト指向インタフェースでは，以下のように階層的にコンテナや基本パーツを配置する。
Figure (図)コンテナ 全ての描画オブジェクトに対して，一番上の階層にあるクラス。 複数のグラフ等(Axesオブジェクト等)を配置するキャンバス的な役割のオブジェクト Axes (座標系)コンテナ 個々のグラフ等に対応するオブジェクト 以下の座標軸(Axis)や描画グラフ(Primitives)を要素として登録する Axis (座標軸)コンテナ 個々の座標軸を表現するオブジェクト ラベルや目盛りなどを要素とする Primitives (基本パーツ) 直線オブジェクト(Line2D), テキストオブジェクト(Text)など各グラフに描画するオブジェクト コンテナの中に配置する (例)</description>
    </item>
    <item>
      <title>Jupyter notebook</title>
      <link>https://moematsuda-ai.github.io/watanuki/python/jupyter/index.html</link>
      <pubDate>Tue, 22 Nov 2022 08:09:35 +0000</pubDate>
      <guid>https://moematsuda-ai.github.io/watanuki/python/jupyter/index.html</guid>
      <description>Jupyterの語源と読み方 もともと，プログラミング言語 Julia と Python と R を実行できる環境だったため Jupyter と名付けられたらしい。 ギリシャ神話の神様ユピテル(ジュピター)とかけてるのだと思うが，こちらの綴は Jupiter と1文字違う。
Jupyterのほうは，Python(パイソン)の読み方に合わせて国内では&amp;quot;ジュパイター&amp;quot;と読む人もいるが，開発者は&amp;quot;ジュピター&amp;quot;と呼んでいるようで，Youtubeにある英語でのjupyter関連の解説を聞いても大抵&amp;quot;ジュピター&amp;quot;に聞こえる。 セル 編集モードへの変更：ダブルクリックまたは&amp;quot;Enter&amp;quot; コマンドモードへの変更：ESC セルの内容の実行 Windows：Ctrl+Enter MacOS：command+Return OS共通：Shift+Enter Markdownセルとcodeセル Markdownセル：テキストを入力するためのセル Codeセル：Pythonの実行を行うセル arkdownセルの編集方法 &amp;ldquo;#&amp;ldquo;でタイトル &amp;ldquo;##&amp;ldquo;でサブタイトル &amp;ldquo;-&amp;ldquo;で箇条書き &amp;ldquo;太文字&amp;ldquo;で太文字 便利なショートカットキー（Window） コマンドモード ショートカットキー 説明 F 検索・置換 Ctrl -Shift Ctrl -Shift Enter 編集モードにする P コマンドパレットを開く Shift -Enter Ctrl -Enter Alt -Enter Y コードセルにする M マークダウンセルにする R rawセルにする 1 見出し１にする 2 見出し２にする 3 見出し３にする 4 見出し４にする 5 見出し５にする 6 見出し６にする K 上のセルを選択する Up 上のセルを選択する Down 下のセルを選択する J 下のセルを選択する Shift -K Shift -Up Shift -Down Shift -J A 上にセルを追加する B 下にセルを追加する X 選択しているセルをカット C 選択しているセルをコピー Shift -V V 下に貼り付け Z セルの削除をやり直す DD 選択しているセルを削除する Shift -M Ctrl -S S 保存する L 行番号の表示・非表示 O セルの出力結果の表示・非表示 Shift -O H キーボードショートカット表示 I×2 カーネルをインタラプト 0 カーネルを再起動 Esc ページャーを閉じる Q ページャーを閉じる Shift -L Shift -Space Space 下にスクロール 編集モード ショートカットキー 説明 Tab コード補完・タブ Shift-Tab ツールチップ Ctrl-] インデント Ctrl-[ ディデント Ctrl-A 全選択 Ctrl-Z やり直し Ctrl-Shift - Ctrl-Y やり直し Ctrl-Home セルの最初に移動 Ctrl-Up セルの最初に移動 Ctrl-End セルの最後に移動 Ctrl-Down セルの最後に移動 Ctrl-Left 一単語前に移動 Ctrl-Right 一単語後に移動 Ctrl-Backspace 前の単語を削除 Ctrl-Delete 後の単語を削除 Ctrl-M コマンドモードにする Ctrl-Shift-F コマンドパレットを開く Ctrl-Shift-P コマンドパレットを開く Esc コマンドモードにする Shift-Enter セルを実行し、下のセルを選択する Ctrl-Enter セルを実行する Alt-Enter セルを実行し、下にセルを追加する Ctrl-Shift-Minus セルを分割する Ctrl-S 保存する Down カーソルを下に移動 Up カーソルを上に移動 Ctrl-/ 選択部分をコメントアウト Kernel セルの左の &amp;ldquo;In[]&amp;rdquo; の括弧内の数字は実行を行った順番を示す。 順番によっては正常に作動しない場合もあるため最後は左上の欄から&amp;quot;Kernel &amp;gt; Restart &amp;amp; Run All&amp;quot;をクリック </description>
    </item>
    <item>
      <title>Function</title>
      <link>https://moematsuda-ai.github.io/watanuki/python/function/index.html</link>
      <pubDate>Tue, 22 Nov 2022 08:09:22 +0000</pubDate>
      <guid>https://moematsuda-ai.github.io/watanuki/python/function/index.html</guid>
      <description>基本演算 Cとおおむね同じ (演算子一覧は p.54, 71) ただし，++, --は使えない。+=, -=は使える 関数の定義 defで始まる行で関数名と引数を定義する 次行から関数の終わりまではインデントして命令文を書く 書式
def function_name(args): &amp;#34;&amp;#34;&amp;#34;Docstring&amp;#34;&amp;#34;&amp;#34; 命令文 #ここから関数の終わりまでインデントをする return result Docstring（ドックストリング） は　help(function_name) を実行したときに出力される文字列（function_name関数の説明文）のこと。一般的に関数名の直後に書き、三重引用符で囲む ただし，返り値は省略できる。 C言語と同様に引数を設定して呼び出せば実行できる。 print_name(&amp;#34;Yamaguchi&amp;#34;,&amp;#34;Daisuki&amp;#34;) My name is Daisuki Yamaguchi. 引数名をつけて，引数の値を指定することもできる。 print_name(family=&amp;#34;Yamaguchi&amp;#34;,first=&amp;#34;Daisuki&amp;#34;) My name is Daisuki Yamaguchi. 引数名をつければ，引数の順番はランダムでも良い print_name(first=&amp;#34;Daisuki&amp;#34;,family=&amp;#34;Yamaguchi&amp;#34;) My name is Daisuki Yamaguchi. 引数のデフォルト値, p.243 引数にデフォルト値を設定することもできる。
def print_name(family=&amp;#34;Momo&amp;#34;,first=&amp;#34;Taro&amp;#34;): # family: 姓, first: 名 print(&amp;#34;My name is {0} {1}.&amp;#34;.format(first, family)) デフォルト値の設定されている引数は，呼び出し時に省略可能。以下ではfamilyの方のみ省略している。
print_name(first=&amp;#34;Daisuki&amp;#34;) 実行結果 My name is Daisuki Momo.
複数の返り値をもつ関数 Pythonの関数では，返り値を複数指定できる。</description>
    </item>
    <item>
      <title>Filter with python</title>
      <link>https://moematsuda-ai.github.io/watanuki/python/filter/index.html</link>
      <pubDate>Tue, 22 Nov 2022 08:09:03 +0000</pubDate>
      <guid>https://moematsuda-ai.github.io/watanuki/python/filter/index.html</guid>
      <description>filtfiltを用いたバンドパスフィルタ(バターワースフィルタ)の記述例 #バターワースフィルタ（バンドパス） fp = np.array([25, 50]) #通過域端周波数[Hz] fs = np.array([10, 100]) #阻止域端周波数[Hz] gpass = 3 #通過域端最大損失[dB] gstop = 40 #阻止域端最小損失[dB] def bandpass(x, samplerate, fp, fs, gpass, gstop):#samplerate がサンプリング周波数 fn = samplerate / 2 #ナイキスト周波数 wp = fp / fn #ナイキスト周波数で通過域端周波数を正規化 ws = fs / fn #ナイキスト周波数で阻止域端周波数を正規化 N, Wn = signal.buttord(wp, ws, gpass, gstop) #オーダーとバターワースの正規化周波数を計算 b, a = signal.butter(N, Wn, &amp;#39;bandpass&amp;#39;) #フィルタ伝達関数の分子と分母を計算 y = signal.filtfilt(b, a, x) #信号に対してフィルタをかける return y #フィルタ後の信号を返す y = bandpass(f_biceps, samplerate, fp, fs, gpass, gstop) scipy.</description>
    </item>
    <item>
      <title>Dict</title>
      <link>https://moematsuda-ai.github.io/watanuki/python/dict/index.html</link>
      <pubDate>Tue, 22 Nov 2022 08:08:52 +0000</pubDate>
      <guid>https://moematsuda-ai.github.io/watanuki/python/dict/index.html</guid>
      <description>1. 辞書(dict)の特徴 名前 例 リスト(list) L=[&amp;quot;kiwi&amp;quot;, &amp;quot;banana&amp;quot;, &amp;quot;apple&amp;quot;] インデックス番号付き集合 タプル(tuple) T=(&amp;quot;kiwi&amp;quot;, &amp;quot;banana&amp;quot;, &amp;quot;apple&amp;quot;) インデックス番号付き集合(代入不可) 辞書(dict) D={&amp;quot;kiwi&amp;quot;:3, &amp;quot;banana&amp;quot;:2, &amp;quot;apple&amp;quot;:3} インデックス番号無し (key,value) 対応表 集合(set) S={&amp;quot;kiwi&amp;quot;, &amp;quot;banana&amp;quot;, &amp;quot;apple&amp;quot;} インデックス番号無し集合 書式: dict_name={key 1: value 1, key 2: value 2, ...} 辞書(dict)には，検索のためのkeyと，検索キーに紐付けられるvalueのペアを登録する。 各要素に対するインデックスは存在しない。 注意:
Python 3.5以前 ではdictに対する要素の登録順序と，実際に保存されている順序と異なることがある。(順序非保存) Python 3.7以降 ではdictでも順序は保存(順序保存) Python 3.6では非公式に順序保存 2. dictの定義 reward={&amp;#34;cheese&amp;#34; : 100 , # リストや辞書等では，折返し記号&amp;#34;\&amp;#34;なしで改行可 &amp;#34;enemy&amp;#34; : -10, &amp;#34;friend&amp;#34; : -1} print(reward) print(reward[&amp;#34;friend&amp;#34;]) # 辞書の参照は dict[key] Qvalue={(1,&amp;#34;right&amp;#34;) : 0.5, (1,&amp;#34;left&amp;#34;) : 1.</description>
    </item>
    <item>
      <title>Create Library</title>
      <link>https://moematsuda-ai.github.io/watanuki/python/create-library/index.html</link>
      <pubDate>Tue, 22 Nov 2022 08:08:38 +0000</pubDate>
      <guid>https://moematsuda-ai.github.io/watanuki/python/create-library/index.html</guid>
      <description>ライブラリの作成方法 directory に __init.py__ ファイルを作成 site-packages ディレクトリに作成したライブラリを追加する（シンボリックリンクでも可） site-packages の場所は $ python -m site で確認できる ディレクトリをパスに追加する場合は次の通り $ export PYTHONPATH=&amp;#34;&amp;lt;path&amp;gt;:$PYTHONPATH&amp;#34; </description>
    </item>
    <item>
      <title>Class</title>
      <link>https://moematsuda-ai.github.io/watanuki/python/class/index.html</link>
      <pubDate>Tue, 22 Nov 2022 08:08:17 +0000</pubDate>
      <guid>https://moematsuda-ai.github.io/watanuki/python/class/index.html</guid>
      <description>クラス(class) 1. 用語(クラス, インスタンス，オブジェクト) クラス pythonにおける型のようなもの。予め定義されているものもあるが，ユーザが定義して使うこともできる。 例) int, float, list, tuple, dict 名簿を作るとき，住所や名前を書いてもらう様式(テンプレート)に該当 インスタンス (instance) クラス(型)から生成されるデータのこと。インスタンス・オブジェクトともいう intはクラス，1, 2, ..はインスタンス listはクラス, [1, 3]はインスタンス 名簿用テンプレートの空欄に，実際にデータを書いてもらった1枚1枚にインスタンスは対応 オブジェクト(object) 定義できるものはなんでもかんでもオブジェクト。。。 例) クラスもインスタンスもメソッドもオブジェクト。 2. クラスを作る キーワード 初期化メソッド 定義したクラスによりインスタンスを生成するときに実行される関数 インスタンス変数 クラス内の様々なメソッド(関数)で使うことができる変数。クラス内でのみ使える大域変数のようなもの。 大抵，初期化メソッドで生成・参照。 クラス内では， self.nameのように，必ずself.をつけて参照する(具体例は次のセルの問に) インスタンス化したオブジェクトからは，オブジェクト名.変数名 (taro.nameなど)で参照(具体例は次のセルの問に) インスタンス・メソッド クラス内で第一引数にselfを指定して定義する関数 クラス内ではself.関数名 で相互参照できる(引数からはselfは省略) インスタンス化したオブジェクトからは，オブジェクト名.関数名 で参照(呼び出し時に第一引数selfは省略) クラスの例 class Name_list: def __init__(self, family=&amp;#34;Momo&amp;#34;, first=&amp;#34;Taro&amp;#34;): # 初期化メソッド(インスタンス生成時に実行) self.family = family # インスタンス変数 family の生成 self.first = first # インスタンス変数には&amp;#34;self.&amp;#34;をつける def print(self): # インスタンス・メソッド(第一引数は必ずself) print(&amp;#34;My name is {} {}.</description>
    </item>
    <item>
      <title>Anaconda Update</title>
      <link>https://moematsuda-ai.github.io/watanuki/python/anaconda-update/index.html</link>
      <pubDate>Tue, 22 Nov 2022 08:08:01 +0000</pubDate>
      <guid>https://moematsuda-ai.github.io/watanuki/python/anaconda-update/index.html</guid>
      <description>pip のアップデート pip と setuptools のアップデート $ python -m pip install --upgrade pip setuptools ※-mはインターフェイスオプションで、pythonのモジュール（パッケージ）を実行するために使用
パッケージのアップデート $ pip install -U &amp;lt;package-name&amp;gt; または
$ pip install --upgrade &amp;lt;package name&amp;gt; naconda のアップデート すべてのパッケージをアップデート $ conda update --all 特定のパッケージのアップデート $ conda update &amp;lt;package name1&amp;gt; &amp;lt;package name2&amp;gt; anaconda 本体のアップデート $ conda update -n base -c defaults conda または
$ conda update -n base conda ※上は(base)と作成した仮想環境両方アップデートされた…（下のコマンドは不明）
※よく使うオプションは以下の通り
-n は --name の略で、環境名の指定 -c は --channel の略で、デフォルトリポジトリだけでなくチャネルを追加で指定 参考 Anaconda パッケージ アップデート方法 pipでアップデートするときのコマンド pip update </description>
    </item>
    <item>
      <title>Tuple</title>
      <link>https://moematsuda-ai.github.io/watanuki/python/tuple/index.html</link>
      <pubDate>Tue, 22 Nov 2022 08:07:41 +0000</pubDate>
      <guid>https://moematsuda-ai.github.io/watanuki/python/tuple/index.html</guid>
      <description>タプル(tuple) Pythonにはデータの集合を扱うための様々なデータ型がある。
以下は標準で用意されているもの。
名前 例 リスト(list) L=[&amp;quot;kiwi&amp;quot;, &amp;quot;banana&amp;quot;, &amp;quot;apple&amp;quot;] インデックス番号付き集合 タプル(tuple) T=(&amp;quot;kiwi&amp;quot;, &amp;quot;banana&amp;quot;, &amp;quot;apple&amp;quot;) インデックス番号付き集合(代入不可) 辞書(dict) D={&amp;quot;kiwi&amp;quot;:3, &amp;quot;banana&amp;quot;:2, &amp;quot;apple&amp;quot;:3} インデックス番号無し (key,value) 対応表 集合(set) S={&amp;quot;kiwi&amp;quot;, &amp;quot;banana&amp;quot;, &amp;quot;apple&amp;quot;} インデックス番号無し集合 以下は拡張モジュールを利用するもの。
名前 例 numpy.ndarray N=np.array([1,2,3]) 数値計算用の多次元配列 pandas.Series s=pd.Series([280,198],index=[&#39;tomato&#39;,&#39;banana&#39;]) 行に名前がある1次元配列 pandas.DataFrame df=pd.DataFrame([[&#39;tomato&#39;,280],[&#39;banana&#39;, 198]], columns=[&#39;name&#39;,&#39;price&#39;]) 列や行に名前がある2次元配列 タプルの特徴 タプルの定義，要素へのアクセス，スライス等はリストとほぼ同様 リストは要素を[]で囲むが，タプルは()で囲む リストと異なり，一度定義したら要素の書き換えはできない タプルの定義 fruits=(&amp;#34;banana&amp;#34;, &amp;#34;prange&amp;#34;, &amp;#34;apple&amp;#34;) a, b, c = fruits#変数a,b,cへそれぞれ一括代入 L = tuple(range(5)) タプルへの代入 一度定義したタプルの要素を後で書き換えることはできない。
a=(1,2,3,5) a[3]=4 # 要素を書き換えようとするとエラーが出る(試してみること) ただし，以下のように変数に代入されているタプルを別のタプルに置き換えることはできる。
a=(1,2,3,5) a=(5,2,3) # タプルの置き換え (タプル(5,2,3)のidがaの参照先に) </description>
    </item>
    <item>
      <title>python</title>
      <link>https://moematsuda-ai.github.io/watanuki/python/module/index.html</link>
      <pubDate>Tue, 22 Nov 2022 08:07:24 +0000</pubDate>
      <guid>https://moematsuda-ai.github.io/watanuki/python/module/index.html</guid>
      <description>Pythonの便利なモジュール モジュール・パッケージ・ライブラリの違い ライブラリ
クラスや関数を記述したファイル(.py)
パッケージ
いくつかのモジュールを一つのディレクトリ（フォルダ）にまとめたもの
ライブラリ
いくつかのパッケージをまとめたもの。モジュールやパッケージをライブラリと呼ぶことも、、、
pythonのライブラリ Numpy
NumpyとはN次元配列(N-dimensional array, ndarray)を定義し、ベクトルや行列をはじめとする数値計算を行うためのモジュールである。
C言語で記述されているため高速処理可能 Numpyモジュールで生成する配列の型名はnumpy.ndarray pandas
pandasはデータ解析を容易にするPythonのサードパーティライブラリです。 データ構造に対して様々な処理を施す機能を提供しており、他のライブラリをバックエンドとして利用して連携して動作できることやデータに対する豊富な処理機能を備えていることから、高度なデータ解析に欠かせないツールとなっている。NumpyのようにC言語による実装であるため配列演算の高速化が図られている点も大規模データの扱いを容易にする魅力の一つとなっている。
matplotlib
グラフやそれ以外の2次元の形式で行うデータの可視化に用いるライブラリ。
出版に適したグラフを作るのに非常に適しており、IPythonとうまく統合されているためIPythonとmatplotlibはデータのグラフ化や探索を容易に行えるインタラクティブな環境を提供している。 ウィンドウに表示されているツールバーからプロットの特定の領域をズームしたり、プロットで表示されれる範囲を変更することができる。
IPython
インタラクティブで探索的な計算を行うことができ、ロバスト性と生産性を持つ環境が提供される。 Pythonのシェルを拡張したもので、Pythonのコードの記述、テスト、デバッグを加速するように設計されている。特に、インタラクティブなデータ操作とmatplotlibによるデータの可視化に非常に便利。
標準的なターミナル操作形式のIPythonシェル以外にも、次のようなものも提供している。
Webブラウザを通じてIPythonと接続することができる、mathematica風のHTMLノートブック インラインのグラフ描画、複数行の編集、文法のハイライトが可能なQtフレームワークを用いたGUIコンソール 並列・分散コンピューティングをインタラクティブに行える基盤 Scipy
科学計算の計算における様々な一般的な問題に取り組めるパッケージ群。
scipy.integrate：数値積分ルーチンや微分方程式ソルバ scipy.linalg：線形代数ルーチンやnumpy.linalgで提供されている機能を拡張した行列の分解機能 scipy.optimaze：関数の最適化（最短化）と求根アルゴリズム scipy.signal：信号処理ツール scipy.sparse：疎（スパース）なデータを持つ行列や線形システムの解法 scipy.special：ガンマ関数のような多数の一般的な数学の関数を実装したFortanのライブラリSPECFUNを使うためのラッパー scipy.stats：標準的な連続分布や離散分布（密度関数、サンプラー、連続分布関数）、様々な統計検定、その他の記述統計 scipy.weave：配列計算の加速のために用いるインラインでのC++コードを利用するためのツール 標準モジュール モジュール名 記述法 概要 print print(&amp;ldquo;出力1&amp;rdquo;, &amp;ldquo;出力2&amp;rdquo;, sep=&amp;lsquo;sep&amp;rsquo;, end=&amp;lsquo;end&amp;rsquo;) 引数を出力する。sepには値の間に挿入される文字列（デフォルトはsep=&amp;rsquo; &amp;lsquo;）、endには最後の値の後につかされる文字列（デフォルトはend=&amp;rsquo;\n&amp;rsquo;）を指定 dir dir(オブジェクト名) オブジェクトのすべての属性（含まれる関数やメソッド等）を表示 type type(オブジェクト名) どのような型のオブジェクトであるかを確認できる。 sum sum(リスト) リスト要素の数値の合計を返却する input input(&amp;ldquo;文字列&amp;rdquo;) 文字列を出力し、キーボードからの入力を返却する max max(x,y,z,key=function) x,y,zの中で最も大きい値を返却する。key&#39;に任意の関数f(x)を渡すと argmax f(x)&amp;lsquo;を計算する（関数f(x), f(y), f(z) の計算結果が最大となる変数を返す) Jupyter notebook コマンド 記述法 概要 %timeit %timeit function() 指定した関数の実行時間を計算 NumPyライブラリ モジュール名 記述法 import 概要 arange np.</description>
    </item>
  </channel>
</rss>