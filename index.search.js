var relearn_search_index = [
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "C_lang",
    "uri": "/watanuki/c_lang/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Docker",
    "uri": "/watanuki/docker/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Github",
    "uri": "/watanuki/github/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Gnuplot",
    "uri": "/watanuki/gnuplot/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Latex",
    "uri": "/watanuki/latex/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Markdown",
    "uri": "/watanuki/markdown/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Posts",
    "uri": "/watanuki/post/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Python",
    "uri": "/watanuki/python/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Keyboard",
    "uri": "/watanuki/keyboard/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Moai's blog",
    "uri": "/watanuki/index.html"
  },
  {
    "content": "US配列でmozc（日本語）の使用 Ubuntu 22.04 入力ソースの変更 設定の地域と言語から，入力ソースを日本語（Mozc）のみにする Mozcのみに設定すると自動的に（たぶん）US配列に対応します キー割当の変更（半角全角キーをctrl+spaceに変更） 設定の『キーボード」の設定を選択 日本語（Mozc）の右側をクリックし，設定をクリック Mozc プロパティの「キー設定の選択」の「編集」を選択し，Hankak/zenkakuのところをすべてCtrl+Spaceに変更 モード/コマンドが以下3つのところの入力キーのところを3回クリック 変換前入力/半角空白を入力 変換中/半角空白を入力 直接入力/IMEを有効化 入力文字なし/IMEを無効化 ctrl+Spaceを押す 参考 Ubuntu18.04にて，USキーボードを用いて英数字と日本語（ひらがな）の切り替えを行う方法 ",
    "description": "",
    "tags": null,
    "title": "Mozc_settings",
    "uri": "/watanuki/keyboard/mozc_settings/index.html"
  },
  {
    "content": "操作方法 gnuplotをC言語のプログラムから制御するには，パイプを使うのが最も簡単である．ここでは，C言語のプログラムによりパイプの生成しgnuplotを起動を行い，パイプを通してコマンドを送る．C言語のプログラム内にコマンドを記述することにより，プログラマーの意図したとおりにgnuplotを操作することができる．\nパイプを開く\nパイプを開くためには，ファイルポインターをつかう．そのためファイルポインターを格 納する変数を用意しなくてはならない．パイプの先もファイルとして扱われるのである． FILE *hoge; 次にgnuplotを立ち上げて，そこにパイプを接続する必要がある．次のようにする． hoge = popen(\"gnuplot -persist\",\"w\"); popen()関数がパイプを開く命令である．これで，gnuplot が立ち上がり，パイプを 通して，コマンドを送ることができる．オプションのpersistで，gnuplotが終了し てもグラフが残るようにしている．そうしないと，コンピューターの動作は高速なので， gnuplotは一瞬にして終了し，グラフが消えてしまい，ほとんど動作内容が分からなく なる．popen()関数の戻り値はパイプの情報を示すファイルポインターである．この ファイルポインターを指定して，コマンドを送ることになる． パイプを通してコマンドを送る パイプを通して，gnuplotにコマンドを送るのはfprintf()関数を使う． c fprintf(hoge, \"plot sin(x)\\n\"); このfprintfを使って，gnuplotにいくらでもコマンドを送ることができる．あたかも，C言語の向こう側でgnuplotが立ち上がって，それから命令を送っているかのように動作する．このようなことができるのが，コマンドを打ち込むCharacter-based User Interface(CUI)の良いところである．\nパイプを閉じる すべての動作が終了したならば，パイプを閉じなくてはならない．これも，ファイルの操作と全く同じである． c pclose(hoge); （例）三角関数のグラフ作成プログラム\n1 #include \u003cstdio.h\u003e 2 3 int main(void){ 4 FILE *gp; 5 6 gp = popen(\"gnuplot -persist\",\"w\"); 7 fprintf(gp, \"plot sin(x)\\n\"); 8 9 pclose(gp); 10 11 return 0; 12 } 参考文献 c言語からgnuplotを操作する(平成19年7月11日、山本昌志) ",
    "description": "",
    "tags": null,
    "title": "Using gniplot on C",
    "uri": "/watanuki/c_lang/using_gniplot/index.html"
  },
  {
    "content": "ファイル分割 c言語のファイル分割では関数等を書き込むファイル.c``.hファイルとmain関数を書き込むファイルの3つのファイルを用意する\n関数を書き込むcalc.cファイル\n#ifndef _CALC_H_ #define _CALC_H_ // 関数avgのプロトタイプ宣言 double avg(double,double); #endif // _CALC_H_ calc.hファイル\n#include \"calc.h\" // 平均値を求める関数 double avg(double l,double m){ // 引数l,mの平均値を求め、rに代入する。 double r = (l + m) / 2.0; return r; } このファイルでは次のようにファイルに書き込み、プロトタイプ宣言を行う\n#ifnfdef _(大文字で記述したファイル名)_H_ #define _(大文字で記述したファイル名)_H_ プロトタイプ宣言; プロトタイプ宣言; ： #endif // _（大文字で記述したファイル名)_H_ ここで登場した#ifndef``#define``#endifはマクロといい、二重インクルードを防いでいる\nmain関数を書き込むmain.cファイル\n#include \u003cstdio.h\u003e #include \"calc.h\" void main(){ double d1,d2,d3; double a = 1.2,b = 3.4,c = 2.7; // 同じ計算が3回(関数を呼び出して計算） d1 = avg(a,b); d2 = avg(4.1,5.7); d3 = avg(c,2.8); printf(\"d1 = %f,d2 = %f,d3 = %f¥n\",d1,d2,d3); } コンパイルの仕方 gcc はコマンドラインで与えられたソースファイルしか読み込まないため、すべての.cソースファイルをまとめ上げて実行する必要がある\n下記2パターンの方法で実行が可能\n(即席回答)１コマンドで\n$ gcc main.c calc.c ※-o オプションで実行ファイル名を指定することも可能\nこの方法ではオブジェクトファイル*.oは最後に掃除・削除されるため残らない\n3コマンドで\n$ gcc -c main.c $ gcc -c calc.c $ gcc main.o calc.o -c オプションではオブジェクトファイル*.oを作るところまでしてくれる\nこの方法では途中までの.oファイルも残るため、途中でコンパイルエラーが起きてもそれまでのオブジェクトファイルは残るという利点がある。したがってたくさんの*.cファイルで構成される実務プログラムではこの方法で１本ずつコンパイルシていくのが一般的担っている。\nc言語コンパイルのちょこっと解説 gcc は、3つの下請けを順次起動する、親玉に過ぎません。\nプリプロセッサ - #include や #define を処理、本来(?)のC言語ソースにする コンパイラ - *.c をコンパイルし、オブジェクトファイル *.o を作る リンカ - 1個以上の *.o をまとめあげ、1個の実行形式ファイル(Windowsなら *.exe)を作る gcc の -c オプションは、「上記2.まででいいよ」指示です。\n即席回答 1. のやりかたは、これを全部まとめて1回にしてるだけ。\n*.o は、実は途中でできてますが、こういう要求のしかたをされたgcc は、最後にキレイに掃除・削除してしまいます。\n参考 一週間で身につくc言語の基本 -ファイル分割- 一週間で身につくc言語の基本 -複雑なファイル分割- Yahoo!知恵袋 -ソースファイルを複数使ったプログラムのコンパイル- もう一度基礎からc言語 -プロトタイプ宣言の省略- ",
    "description": "",
    "tags": null,
    "title": "Method of file division",
    "uri": "/watanuki/c_lang/file_sep/index.html"
  },
  {
    "content": "プリアンブル Packages \\documentclass[dvipdfmx]{jsarticle} \\usepackage[dvipdfmx]{graphicx} \\usepackage[dvipdfmx]{color} \\usepackage{amsmath} \\usepackage{mathtools} \\usepackage{ascmac} \\usepackage{comment} \\usepackage{algorithmic} \\usepackage{algorithm} \\usepackage{here} \\usepackage{listings,jvlisting} \\usepackage{bm} \\usepackage{multicol} \\usepackage[square,sort,comma,numbers]{natbib} \\usepackage[subrefformat=simple]{subcaption}%サブキャプションを付けたいときに必要 gnuplotでlatex形式の数式を表示するための設定 % \\usepackage{gnuplot-lua-tikz} % \\usepackage{tikz} algorithm (疑似コード) の表示の設定 \\renewcommand{\\algorithmicrequire}{\\textbf{Input:}} \\renewcommand{\\algorithmicensure}{\\textbf{Output:}} ### 参考文献の文献番号の表示形式を変更 \\makeatletter%再定義に＠が使用される場合に\\makeatletterと\\makeatotherで挟む \\def\\@cite#1{\\textsuperscript{#1)}}%引用文献の文献番号の表示方法を変更 \\def\\@biblabel#1{#1)}%参考文献の先頭も変更 \\makeatother 文献番号等の色やリンクの設定 \\usepackage[dvipdfmx]{hyperref} \\hypersetup{% hyperrefオプションリスト setpagesize=false, bookmarksnumbered=true,%ブックマークを作成 bookmarksopen=true,%ブックマークを開く colorlinks=true,%カラーリンクを使用 linkcolor=black, %内部参照リンクカラー citecolor=blue, %文献カラー % filecolor=, %ローカルファイル参照リンクカラー urlcolor=blue, } program（c言語）の記述形式についての設定 \\renewcommand{\\lstlistingname}{program} % %c言語の設定 気に入ってる方 \\lstset{ language=c, basicstyle={\\ttfamily\\small}, tabsize=2, frame=trBL, numbers=left, numberstyle={\\ttfamily\\small}, breaklines=true, captionpos=t %キャプションを一番下にするならcaptions=b } jsreportでchapterの改行を削除する設定 % chapterの改行を削除 \\makeatletter \\def\\@makechapterhead#1{% \\vspace*{2\\Cvs}% 欧文は50pt {\\parindent \\z@ \\raggedright \\normalfont \\ifnum \\c@secnumdepth \u003e\\m@ne \\huge\\headfont \\@chapapp\\thechapter\\@chappos %% \\par\\nobreak %% \\vskip \\Cvs % 欧文は20pt \\fi \\interlinepenalty\\@M%先頭の空白で、章とチャプター名の間に空白が挿入される \\huge \\headfont #1\\par\\nobreak \\vskip 3\\Cvs} } % 欧文は40pt \\makeatother In document bibtexの表示 \\bibliographystyle{junsrt} \\nocite{*} \\bibliography{reference} ",
    "description": "",
    "tags": null,
    "title": "よく使う設定",
    "uri": "/watanuki/latex/myset/index.html"
  },
  {
    "content": "markdown 記法 コマンド 概要 表示例 #[space] セクション — ##[space] サブセクション — ###[space] サブサブセクション — -[space] 箇条書きリスト — 1.[space] 1.[space] 番号付きリスト (数字はすべて1と記入することで順番に番号が割り振られる) — - [ ] 文字 チェック付き箇条書きリスト — \u003e[spave] 引用 — »[space] 二重引用 — *[文字]* イタリック体 イタリック **[文字]** bold（太字） bold ***[文字]*** 強調(イタリック\u0026ボールド) 強調 ~~取り消し線~~ 取り消し線 取り消し線 *** 水平線(アスタリスクの変わりに---や___でも良い) — [リンク名](URL) リンクの記述 Markdown記法 `[文字]` 文字の強調 str ```pythonprint(“Hello World) ``` ソースコードの記入(その他にもc言語やgnuplotなどでも使用できる) — \u003cbr\u003e 改行 改行します※改行後に文字を記入 \u0026nbsp 半角スペース \u0026ensp 半角より少し広めの空白 \u0026emsp 全角スペース \u0026thinsp, \u0026nbsp より狭い空白 ※表示例が空欄のところは下記を参照\nセクション 〜様々な記法の表示例〜 サブセクション ## サブセクション サブサブセクション ### サブサブセクション サブサブサブセクション・・・ #### サブサブサブセクション・・・ 箇条書き\u0026番号付きリスト A B C D E F a b 箇条書き1 箇条書き2 - A - B - C - D - E - F 1. a 1. b - [ ] 箇条書き1 - [X] 箇条書き2 引用 引用1\n二重引用\n\u003e引用1 \u003e\u003e二重引用 ソースコード（Python, c) for i in range(0, 10, 1): print(i) #include\u003cstdio.h\u003e int main(void){ int i; for(i = 0; i \u003c 10; i++){ print(i); } return 0; } ```python for i in range(0, 10, 1): print(i) ``` ```c #include\u003cstdio.h\u003e int main(void){ int i; for(i = 0; i \u003c 10; i++){ print(i); } return 0; } ``` 下線 アンダーラインの例\n\u003cu\u003e 下線のcode \u003c/u\u003e 数式 数式は$や$$で囲むことでlatexと同様に表示することができる\n$は $\\Deltax` のように組み込み\n$$ は下記のように段落形式になる $$ x = \\frac{-b\\pm\\sqrt{b^2}-4ac}{2a} $$\n\u003cscript type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML\"\u003e \u003c/script\u003e \u003cscript type=\"text/x-mathjax-config\"\u003e MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$'] ], displayMath: [ ['$$','$$'], [\"\\\\[\",\"\\\\]\"] ] } }); \u003c/script\u003e ```math x = \\frac{-b\\pm\\sqrt{b^2}-4ac}{2a} ``` でもOKかも？\n",
    "description": "",
    "tags": null,
    "title": "Basic operation",
    "uri": "/watanuki/markdown/base/index.html"
  },
  {
    "content": "gnuplotでlatex形式の数式を挿入 準備 gnuplot では直接pdfをつくらずLaTeX（TikZ）を経由することで美しいグラフのpdfをつくることができる。\nこのグラフ作成にはtikz環境を使用し、これにより作成されたtexファイルを読み込みタイプセットすることが可能である。\nただしこの環境と関連するファイルはTeXLiveには含まれておらず、Linux等の環境ではGnuplotのインストール時にpackageマネージャーがスタイルファイル gnuplot-lua-tikzとそれに関連するファイルをLaTeXが探索するファイルにインストールしてくれるが、Windowsでは自分で環境を整える必要がある。\nターミナル（コマンドプロンプト）でc/texlive/texmx-local/tex/latexに移動し、gnuplotファイルを作成する。 gnuplotを起動してtexlive/texmx-local/tex/latex/gnuplotに移動し、以下のコマンドを実行する。 set terminal tikz createstyle コマンドプロンプト上でgnuplotファイルに移動し、mktexlsrを実行してls-IRを更新する。 TeXソースコードの生成 次のように入力し、出力をtilzにしてプロットする。\nset terminal tikz set output \"filename.tex\" plot sin(x) TeXで画像を出力 次のようにTeXファイルに記入することでfilename.texの画像を出力することができる。\n\\documentclass[dvipdfmx]{jarticle} \\usepackage{tikz} \\usepackage{gnuplot-lua-tikz} \\begin{document} \\input{filename.tex} \\end{document} 【参考文献】 gnuplotからTikZを介してpdfを生成 Gnuplot で LaTex 用の綺麗なグラフを作成する gnuplotでTeXフォントを用いる ",
    "description": "",
    "tags": null,
    "title": "How to insert formulas like latex",
    "uri": "/watanuki/gnuplot/output_equation_on_latex/index.html"
  },
  {
    "content": "gnuplotのコマンドをファイルで保存する方法 拡張子は.plt コメントは#を使う コマンドを順に入力していけばOK!（コマンドの頭に特殊な文字を入れる必要はない） コマンドファイルの拡張子を.plt以外にした場合 下記のコマンドを打ち込む\n\u003e load \"コマンドファイル名.拡張子\" 参考文献 コマンド・ファイルを実行する ",
    "description": "",
    "tags": null,
    "title": "Command file",
    "uri": "/watanuki/gnuplot/command_file/index.html"
  },
  {
    "content": "基本コマンド 関数の表示 \u003eplot x*x+2 カレントディレクトリの移動 \u003ecd 'C:\\Users' ※ディレクトリやファイル名は’’ ’ ’ ‘‘で囲む\nデータファイルの表示 \u003eplot 'test.dat' ※ファイル名は絶対パスまたは相対パスでOK ※ファイルデータのここの列はスペースで区切る\nデータファイルのフィッティング f(x)=ax**2+bx+c fit f(x) \"data.d\" u 1:2 via a,b,c 【出力結果】\n... Final set of parameters Asymptotic Standard Error ======================= ========================== a = 0.995618 +/- 0.005679 (0.5704%) b = 15.3268 +/- 0.051 (0.3327%) c = 0.970465 +/- 0.04439 (4.574%) ... \u003e ※Final set of parameterが最終的なフィッティングの結果を表す。Asymptotic Standard Errorは何だろ？\n便利なオプション \u003eplot \"ファイル名\" [オプション] オプション 意味 with lines 点と点を線で結ぶ using 1:2 データの1列目をx軸、2列めをy軸にとってプロットする with points pointtype 2 (pointtypeをptと略してもOK！) 点の種類を2に変える ※【参考】「gnuplotのグラフを調整するには」 with lines linetype 3 (linetypeをltと略してもOK！) 線の種類を3に変える with lp lt 3 lw 2 pt 5 ps 2 線の種類(lt)を3番目のもの，線の太さ(lw)を2に，点の種類(pt)を5番目のもの，点の大きさ(ps)を2にする。 (lp=linespoints,lt=linetype，lw=linewidth，pt=pointtype，ps=pointsize) title “データのラベル” プロットするデータの名前（凡例）を指定する※【参考】「凡例、ラベル等」 unset key (またはnotitle) データの名前（凡例）を消す グラフの調整 \u003eset [オプション] オプション 意味 xtics 1 x軸の目盛間隔を設定 title “タイトル” グラフのタイトルを設定 xlabel “ラベル” x軸の軸ラベルを設定 mxtics [数] x軸の副目盛の数を設定　※[数]は省略可。標準では1個の主目盛を10等分するように設定されている。 label at first 1.0,1.0 “コメント” x軸、y軸上の指定の位置（ここでは（1.0,1.0））に文字を書く　※詳しくはグラフに文字を書く参照 arrow from 1.0,0.0 to 1.0,4.0 nohead (1.0, 0.0)から(1.0, 4.0)まで線を引く（データラベルはなし） 参考文献 きれいなグラフを作ろう！gnuplot入門 副目盛の表示と目盛の調整 gnupotで軸に平行な線を引く [] ",
    "description": "",
    "tags": null,
    "title": "basic operation",
    "uri": "/watanuki/gnuplot/base/index.html"
  },
  {
    "content": "gnuplotのインストール方法 $ sudo apt update $ sudo apt install gnuplot $ sudo apt install gnuplot-x11 gnuplot-x11をインストールすると、出力端末が\"X11\"になる。\n出力端末は以下の3つのパッケージが使用可能。ただしこれらは 排他的なパッケージのため、どれか1つのみしかインストールできない。 （他のをインストールしようとすると、すでにインストールされていた パッケージはアンインストールされる。）\ngnuplot-qt gnuplot-x11 gnuplot-nox 参考 Ubuntuのリポジトリからインストールできるgnuplotのパッケージについて LinuxにGnuplotをインストール ",
    "description": "",
    "tags": null,
    "title": "How to install gnuplot",
    "uri": "/watanuki/gnuplot/install/index.html"
  },
  {
    "content": "グラフが記述した位置に正しく出力されない もとのやり方 \\begin{figure}[h] \\end{figure} このやり方では画像を連続して出力する場合などにテキストの最後にまとめて出力されてしまう。\n解決法 usepackage{here} \\begin{figure}[H]%[H]オプションで記述した位置に強制的に出力する \\end{figure} 参考 TeXで図をコード記述位置に強制的に出力する\n図表番号が正しく表示されない。 問題点 \\begin{figure}[H] \\label{graph3_4} \\begin{center} \\scalebox{0.9}{\\input{kadai3_4_graph.tex}} \\caption{$\\alpha = 1/4 $における分散$\\langle x(t)\\rangle$と時間$t$の関係} \\end{center} \\end{figure} \\begin{figure}[h] \\label{graph3_2} \\begin{center} \\scalebox{0.9}{\\input{kadai3_2_graph.tex}} \\caption{$\\alpha = 1/2$における分散$\\langle x(t)\\rangle$と時間$t$の関係} \\end{center} \\end{figure} \\begin{figure}[h] \\label{graph3_1} \\begin{center} \\scalebox{0.9}{\\input{kadai3_1_graph.tex}} \\caption{$\\alpha = 1$における分散$\\langle x(t)\\rangle$と時間$t$の関係} \\end{center} \\end{figure} 図\\ref{graph3_4}, \\ref{graph3_2}, \\ref{graph3_1} と書くと図4, 4, 4と出力されてしまう\n解決法 captionの中にlabelをかく\n\\begin{figure}[H] \\begin{center} \\scalebox{0.9}{\\input{kadai3_4_graph.tex}} \\caption{$\\alpha = 1/4 $における分散$\\langle x(t)\\rangle$と時間$t$の関係\\label{graph3_4}} \\end{center} \\end{figure} 参考 LaTeXの図番号がおかしい問題 - \\label{}を\\caption{}内に挿入 ",
    "description": "",
    "tags": null,
    "title": "Problem",
    "uri": "/watanuki/latex/problem/index.html"
  },
  {
    "content": "LaTeXでの参考文献の書き方 \\begin{thebibliography}{99} \\bibitem{参照ラベル名1} 文献情報 \\bibitem{参照ラベル2名} 文献情報 ...... ...... \\end{thebibliography} このように記述してタイプセットすると、文献番号が\\bibitemの登録順に[1], [2], [3], … のように表される。\n本文中で文献情報を参照するには次のように記述する\n....といったことが指摘されている\\cite{ラベル名a}\\cite{ラベル名b} これをタイプセットすると....といったことが指摘されている[6][9]のように表示される。\n文中で文献番号だけでなくページ数などをオプション表示させるには次のように記述する。\n....といったことが指摘されている \\cite{ラベル名a}\\cite[第3章127ページ]{ラベル名b}。 引用を上付き右カッコで表示する LaTeXの引用表示を[xxx]ではなくxxx)にする方法。プリアンブルに次のように書く。\n\\makeatletter \\def\\@cite#1{\\textsuperscript{#1)}} \\makeatother 他にいろいろ変えたければ、\\textsuperscript{#1)}の部分を編集する (#1が冒頭に出てきたxxxにあたる)。 参考文献一覧の先頭も同様にに変えたい場合、プリアンブルの\\makeatletter～\\makeatother中に次のように書く。\n\\def\\@biblabel#1{#1)} 〇\\makeatleter, \\maketotherとは？ また，再定義するマクロの名前や再定義の内容に @ が現れる場合は，次のように再定義全体を \\makeatletter と \\makeatother で挟んでおく必要がある．\n\\usepackage{foo} \\makeatletter \\renewcommand\\bar{... 20pt ...} \\makeatother 参考 参考文献情報の書き方 創作メモ 【参考文献の表示の変更】 LaTeX Wiki パッケージ bibtex の使い方 .bib拡張子のファイルを用意し、内容を記述\n% 論文の場合 @article{hoshino2019, author = {Hikaru Hoshino and Yoshihiko Susuki and T. John Koo and Takashi Hikihara}, journal = {Journal of Dynamic Systems, Measurement, and Control}, title = {Structural Analysis and Control of a Model of Two-Site Electricity and Heat Supply}, year = {2019}, volume = {141}, number = {10}, pages = {101004}, doi = {10.1115/1.4043703}, } % 本の場合 @book{biggar2014, author = {Darryl R.Biggar and Mohammad Reza Hesamzadeh}, title = {The Economics of Electricity Market}, publisher = {John Wiley \u0026 Sons}, isbn = {9781118775752}, year = {2014}, } 本文中の参考文献を出力したい一に以下の記述を追加\n\\bibliographystyle{junsrt} %参考文献出力スタイル \\bibliography{hoge} %hoge.bibから拡張子を外した名前 なお、参考文献出力スタイル(bibliographystyle)には主に以下のスタイルがあります。\n欧文用 和文用 特徴 plain jplain 参考文献をアルファベット順で出力する unsrt junsrt 参考文献を引用された順で出力する 参考 thebibliography 環境 BiBTeXとは Qiita 星野光　参考文献の書き方 LaTeX 参考文献処理(BibTeX) BiBTeXでのURLの書き方 学術論文の情報をそれらしい形で出力する方法 Quiita ",
    "description": "",
    "tags": null,
    "title": "References",
    "uri": "/watanuki/latex/references/index.html"
  },
  {
    "content": "記号付き箇条書き 見出し記号付きの箇条書きをするためには¥itemizeを使用する。\n【入力例】\n¥begin{itemize} ¥item aaa ¥item bbb ¥begin{itemize} ¥item ccc ¥end{itemize} ¥item ddd ¥end{itemize} 【出力例】\n・ aaa ・ bbb - ccc ・ ddd itemizeのマークの変更 itemizeを入れ子にすると、各項目の見出しとなる記号が変化する。 これらの記号は、クラスファイルのなかで次の命令に定義されている。\nレベル 命令 デフォルト １ ¥labelitemi ● ２ ¥labelitemii − ３ ¥labelitemiii ＊ ４ ¥labelitemiv ・ 【入力例１】itemizeの第１レベルの見出し記号を”○”に変更\n¥renewcommand{¥labelitemi}{○} ¥begin{itemize} ¥item マークが変わった！ ¥end{itemize} 【出力例１】\n○ マークが変わった！ 【入力例２】見出し記号を１つだけ”○”に変更\n¥begin{itemize} ¥item 普通のマーク ¥item[○]マークが変わります ¥end{itemize} 【出力例２】\n・ 普通のマーク ○ マークが変わります 番号付き箇条書き 見出し番号付きの箇条書きをするためには¥enumerateを使用する。\n【入力例】\n¥begin{enumerate} ¥item aaa ¥begin{enumerate} ¥item bbb ¥begin{enumerate} ¥item ccc ¥end{enumerate} ¥end{enumerate} ¥item ddd ¥item eee ¥end{enumerate} 【出力例】\n1. aaa (a) bb i. ccc 2. ddd 3. eee enumerateの番号の変更 enumerateの番号の出力形式を変更するには、カウンタの値を出力する命令を定義し直す。\nレベル カウンタ 出力する命令 デフォルトの出力 １ enumi ¥theenumi アラビア数字（１，２，３，・・・） ２ enumii ¥theenumii 小文字のアルファベット（a，b，c，・・・） ３ enumiii ¥theenumiii 小文字のローマ数字（小文字のローマ数字（ⅰ，ⅱ，ⅲ，・・・） ４ enumiv ¥theenumiv 大文字のアルファベット（A，B，C，・・・） 【例】¥enumiカウンタを大文字のローマ数字で出力する設定\n¥renewcommand{¥theenumi}{¥Roman{enumi}} 番号の出力形式 命令 出力形式 ¥arabic アラビア数字（１、２、３、・・・） ¥roman ローマ数字（ⅰ、ⅱ、ⅲ、・・・） ¥Roman ローマ数字（Ⅰ、Ⅱ、Ⅲ、・・・） ¥alph アルファベット（a、b、c、・・・） ¥Alph アルファベット（A、B、C、・・・） 見出し語付き箇条書き 見出し語付きの箇条書きをするためには¥descriptionを使用する。\n【入力例】\n¥begin{description} ¥item[日時] ○月○日 ¥item[場所] どこか ¥item[時間] ○時○分 ¥end{description} 【出力例】\n日時 ○月○日 場所 どこか 時間 ○時○分 参考 箇条書き ",
    "description": "",
    "tags": null,
    "title": "Bulletins in latex",
    "uri": "/watanuki/latex/item/index.html"
  },
  {
    "content": "\\begin{figure}[位置指定] \\centering \\includegraphics[オプション]{ファイル名} \\caption{図のタイトル\\label{ラベル} \\end{figure} .tex拡張子の図を挿入するときは次のように記述する\n\\begin{figure}[H] \\centering \\scalebox{0.6}{\\input{ファイル名}} \\caption{図のタイトル\\label{ラベル}} \\end{figure} 位置指定 位置指定 出力場所 h 記述した部分 t ページの上部 b ページの下部 p 独立したページ オプション オプション指定 指定方法 keepaspectratio 縦横の比を維持 scale 図のサイズの変更(例:scale=0.7) width 横幅の指定(例:width=130mm) height 高さの指定(例:height=60mm) angle 回転角の指定(例:angle=90) origin 回転角の時の原点，c:中心，tl:左上，tr:右上，bl:左下，br：右下(例:origin=c) draft 図が入る枠だけ表示 clip BoundingBoxからはみ出た分を切り取る 複数枚のグラフを横に並べて表示 figure の中で minipage を使って，画像一つ分の領域を確保してから includegraphics を使う． \\linewidth, \\textwidth などを使って領域の幅を調整する． subcaption を使う時は，大抵プリアンブルに次のように書くとよい．\n\\usepackage[subrefformat=parens]{subcaption} subcaption パッケージが使用しているスタイルと競合する場合は諦めて， (a)や(b)などの文字を直接打ち込んで挿入する． 以下は1行2列で2つの画像を挿入する例．\n% --- Figure ------------------------------ \\begin{figure}[H] \\begin{tabular}{cc} % -- (a) -- \\begin{minipage}{0.45\\linewidth} \\centering \\includegraphics[keepaspectratio, scale=0.6]{fig/a.pdf} \\subcaption{1つめ} \\end{minipage} % --------- % \\vspace と \\hspace を駆使して間隔を調節 % -- (b) -- \\begin{minipage}{0.45\\linewidth} \\centering \\includegraphics[keepaspectratio, scale=0.6]{fig/b.pdf} \\subcaption{2つめ} \\end{minipage} % --------- %% main caption \\caption{Hogehoge} \\label{fig:1} \\end{tabular} \\end{figure*} % ----------------------------------------- \\minipage を応用すれば任意の配置で図を置くことができる． \\subcaption{} は minipage の中に必ず入れないといけない点に注意． 入れなかった場合，普通の caption が図Xでなくて (c) 等になってしまう．\n参考 LaTeX 図 LaTeX 図の挿入 TeXで好きな位置に図を配置する TeXによる文書作成 図の挿入 文字の拡大・縮小 - scalebox, resizebox ",
    "description": "",
    "tags": null,
    "title": "Figure",
    "uri": "/watanuki/latex/figure/index.html"
  },
  {
    "content": "表の書き方 \\begin{table} \\label{ラベル名} \\centering \\caption{表題} \\begin{tabular}{|c|c|c|}%3列で表示、列と列の間に縦罫線を引く \\hline 西暦 \u0026 測定者 \u0026 測定方法 \u0026 測定結果 \\\\ \u0026 \u0026 \u0026 $\\times 10^8$ [m/sec] \\\\ \\hline \\hline 1638 \u0026 Galileo \u0026 二人が離れてランプの光を見る \u0026 (音速10倍以上) \\\\ 1675 \u0026 Roemer \u0026 木星の衛星の観測から \u0026 2 \\\\ \\hline \\end{tabular} \\end{table} コマンド コマンド 概要 \\hline 横罫線を引く ※2回かけば2つ横罫線が引かれる \\multicolmn{横に結合するマスの数}{表示形式、|c|等}{文字} 横に並んだ表の要素を結合する \\cline{3-5} 任意の列に横罫線を引く(ここでは3列目から5列目に横罫線を引く) packageを用いた表作成 概要 コマンド 備考 package セルの結合（縦） \\multirow{結合要素数}{*}{文字} 縦に並んだ表の要素を結合 multirow 幅を指定した横罫線 \\toprule[] 表の最上部の横罫線を引きます．は線幅です．線幅を設定しないデフォルトを強く推奨します． booktabs 横罫線(列見出しと本文、幅指定) \\midrule[] 列見出しと本文の間に横罫線を引きます． booktabs 横罫線(表の最下部、幅指定) \\bottomrule[] 表の最下部の横罫線を引きます． booktabs 任意の行への縦罫線 \\cmidrule{a-b} a 行目から b 行目まで罫線を引きます．trim の設定(lr)を強く勧めます． booktabs 行間スペース \\addlinespace[] 行間にスペースを挿入します． booktabs 二重罫線(\\cmidrule) \\morecmidrules \\cmidrule を二重罫線にするときに使います．他の罫線 (\\toprule, \\midrule, \\bottomrule) では不要です． booktabs スペースありの罫線 \\specialrule{}{}{} 上下にスペースを挿入した罫線を引きます．これを使う場合，三つの引数が必須です． booktabs ※＜wd＞は幅指定（pt,em, cmなど)\n※「」は線のトリミングの指定です．「(lr)」とすると，列の幅より少し短い罫線になります．格好良い罫線が引きますので，このオプションをつけることを強く推奨します．「l{-2.3mm}r{3.4mm}」のようにすると，罫線を左側に 2.3 mm 伸び，右側に 3.4 mm 短くなります．\n※「」と「」は，罫線上下の空白の幅を指定します．幅指定は (1pt, 0.5em, 1.2mm) のようにします．\ntabularの設定パラメータ パラメータ 動作 備考 l 左詰(left) — r 右詰 — c センタリング 引き続くブロックのセンタリング指定 p{長さ} 上/左詰めの幅指定カラム(paragraph) — m{長さ} 中/左詰めの幅指定カラム(middle) arry.styが必要 b{長さ} 下/左詰めの幅指定カラム(bottom) arry.styが必要 @{文字列} 文字列がセパレーターになる — ` ` 縦線(1本) ` ` 参考文献 LaTeX 表組 ",
    "description": "",
    "tags": null,
    "title": "Table",
    "uri": "/watanuki/latex/table/index.html"
  },
  {
    "content": "LaTexコマンド集 概要 コマンド 詳細 パッケージ 文字サイズの変更 \\scalebox{倍率}{文字} 特定の文字やtexファイルを＜倍率＞倍にして出力する。{倍率}の部分を{幅}[高さ]のようにかき分けてもOK! graphics 行間の調整 \\begin{spacing}{倍率} 文章 \\end{spacing} 指定した倍率に行間を変更する setspace 部分的に2段組みにする \\begin{multicols}{2} 2段組にしたい文章 \\end{multicols} 2のところをかえれば多段組にできるかも(?) multicol 特殊文字 表示 コマンド 概要 Å {\\AA} 数式環境以外で単位Åを表示する。ただし数式中では\\mathrm{\\mathring{A}}とするか\\mathrm{\\AA}とする。 文字サイズ コマンド 標準を10ptとしたときの大きさ \\tiny 5pt \\scriptsize 7pt \\footnotesize 8pt \\small 9pt \\normalsize 10pt \\large 12pt \\Large 14.4pt \\LARGE 17.28pt \\huge 20.74pt \\Huge 24.88pt 数式環境 環境名 環境 パッケージ 特徴 equation \\begin{equation}\\end{equation} — 1行の数式を記入でき、数式番号がつく equation \\begin{equation*}・・・ amsmath equation環境とほとんど同じだが、数式番号がつかない eqnarray \\begin{eqnarray} 数式 $=$ 数式\\数式 $=$ 数式\\end{eqnarray} — 複数行の数式を、$で挟んでいる＝をそろえて表示する。※数式番号は各行に表示されるが、\\nonumberを使用してはならない。 eqnarray \\begin{eqnarray*}・・・ — 数式番号がつかない split \\begin{split} 数式 $= 数式 数式 $= 数式\\end{split} amsmath eqnarray環境の代替。equation環境の中で使用し、\u0026=をそろえて表示し、数式番号は複数行の中間に一つだけ表示する align \\begin{align} 数式 $= 数式\\・・・ amsmath {\u0026= で数式の=をそろえて表示し、数式番号を各行ごとに表示する。 align \\begin{align*}・・・ amsmath 数式番号がつかない aligned \\begin{aligned}・・・ amsmath equation環境内で使用でき、一部分のみalign環境にすることができる gather \\begin{gather}・・・ amsmath 複数の数式を中央揃えで表示し、各行ごとに数式番号をつける 数式表示 コマンド パッケージ 概要 \\bm{a} bm 括弧内の文字をベクトル（太字）で表示する \\label{数式のラベル} — 数式にラベル付けできる。数式の数式番号やページ数を呼び出すときに使用する。数式環境下で使用する \\ref{ラベル名} — 数式につけた式番号をラベル名を指定することで表示できる \\frac{分子}{分母} — 分数表示 \\int_{上限}^{下限} — 積分表示 \\left\u003c括弧なら何でも\u003e・・・\\right\u003c括弧\u003e — 括弧のサイズを括弧内の数式に自動で合わせる \\hspace{50pt} — { }内に指定した幅の文だけスペースを生成。使用できる単位は「pt」「pc」「mm」「cm」 \\; または \\: または \\, 空白を生成。左に行くにつれて大きくなる \\begin{pmatrix} a11 \u0026 a12 \u0026 a13\\\\\\\\ a21 \u0026 a22 \u0026 a23 \\\\\\\\ \\end{pmatrix} amsmath 行列 \\begin{vmatrix} a11 \u0026 a12 \u0026 a13\\\\\\\\ a21 \u0026 a22 \u0026 a23 \\\\\\\\ \\end{vmatrix} amsmath 行列式 \\cdot — どっと(中央) \\cdots — 3点ドット(中央) \\vdots — 縦の3点ドット \\ddots — 斜めの3点ドット ギリシャ文字 **ギリシャ文字を使用する場合にも数式環境下で記述する必要がある。\n出力 入力 出力 入力 出力 入力 α \\alpha β \\beta γ \\gamma δ \\delta ϵ \\epsilon ε \\varepsilon ζ \\zeta η \\eta θ \\theta ϑ \\vartheta ι \\iota κ \\kappa λ \\lambda μ \\mu ν \\nu ξ \\xi o o π \\pi ϖ \\varpi ρ \\rho ϱ \\varrho σ \\sigma ς \\varsigma τ \\tau υ \\upsilon ϕ \\phi φ \\varphi χ \\chi ψ \\psi ω \\omega Γ \\Gamma Λ \\Lambda Σ \\Sigma Ψ \\Psi Δ \\Delta Ξ \\Xi Υ \\Upsilon Ω \\Omega Θ \\Theta Π \\Pi Φ \\Phi ∑ \\sum ∏ \\prod — — — — 数学記号 出力 コマンド Å \\mathrm{\\mathring{A}} ₁P₂ {}_1P_2 ≤ \\leq ≥ \\geq ∈ \\in ± \\pm ≃ \\simeq ・ \\cdot ∂ \\partial 分数 frac{分子}{分母} ∇ \\nabla Δ（デルタ，ラプラシアン） \\Delta ≡ \\equiv 期待値の記号\u003c\u003e \\langle, \\rangle Ⅱ $\\rm{I\\hspace{-.01em}I}$ A(数式中で斜体表示を解除) \\rm{A} A(行列を表すA，太字かつ斜体無し) \\mathbf{A} Vebatim環境内での数式表示 Verbatim環境内で数式を使う場合は**プリアンブルに\\usepackage{fancyvrb}**と記述し、以下のようにドキュメント内に書く。\n\\begin{spacing}{0.8} \\begin{Verbatim}[commandchars=\\\\\\{\\}, codes={\\catcode`$=3\\catcode`_=8\\catcode`^=7}] $\\sum_[i=1]^[n]M_i$ \\end{Verbatim} \\begin{Verbatim}[%frame=single, numbers=left, commandchars=\\\\\\{\\},codes={\\catcode`$=3\\catcode`_=8\\catcode`^=7}] $f(x) = \\frac{1}{x} \\end{Verbatim} ※どちらがいいのかわからない…\nアルゴリズムの擬似コード https://li-feel.hatenablog.com/entry/2017/12/19/160618 https://qiita.com/jirojiro/items/0ae13aac9112a804f8d5 https://qiita.com/harmegiddo/items/04ae672402bb8c1d01a6 ソースコード LaTeXにソースコードを美しく貼る方法 図の挿入(input) https://hydrocoast.jp/index.php?LaTeX/%E5%9B%B3 https://www.okomeda.net/wp/484/ http://www.yamamo10.jp/yamamoto/comp/latex/make_doc/insert_fig/index.php https://atatat.hatenablog.com/entry/cloud_latex18_subcaption https://medemanabu.net/latex/scalebox-resizebox/ https://qiita.com/poemn/items/9142339749c87ebdb536 表紙テンプレ 卒論をTeXフォーマットなしから書くためのtips Quiita「LaTeXの卒論の表紙テンプレート \u003e\u003c」 参考文献 LaTeX - コマンド一覧 複数行の数式 【LaTeX】括弧類のかき方一覧と大きさの変更方法まとめ TeXで好きな位置に図を配置する LaTeXの特殊文字・特別記号 空白-水平方向のスペース - quad, hspace TeX 行間の調整 【LaTex】 fancyvrb — 洗練されたverbatim拡張機能の提供 TeXの記憶(89) — Verbatim環境の中で数式を表示する ",
    "description": "",
    "tags": null,
    "title": "Basic",
    "uri": "/watanuki/latex/base/index.html"
  },
  {
    "content": "リポジトリのダウンロード GitHubにあるリモートリポジトリをhttps接続でダウンロードする場合は以下のコマンドで。(ただし，GitHub上のリポジトリ設定で若干異なる場合もある)\n$ git clone https://github.com/someone/somerepo.git 上記URLのsomeone, someprepoの部分はダウンロードしたいリポジトリによって変わる。\nssh接続 git clone git@github.com:bcl-exercises/21exercises-MoeMatsuda-ai.git cloneするときのURL以下はブラウザ上のgithubでcloneしたいリポジトリに移動し、codeをクリックすることで確認できる。\npublicの場合 $ git clone https://github.com/jnishii/jgr.git privateの場合 $ git clone https://\u003cusername\u003e@github.com/someone/somerepo.git Wikiページをcloneする場合は.gitの前に.wikiをつける。\n参照 リポジトリをクローンする 最新情報のダウンロード / 更新ファイルのアップロード ダウンロードしたファイルをいじるときには，まず，Gitサーバから最新バージョンをダウンロードしてから開始。\n$ git pull origin main これはサーバ(origin)から，masterブランチ(ブランチは後述)をダウンロードしてローカルリポジトリを更新し(fetch)，作業ディレクトリに反映(merge)するという意味。\nファイルを更新したら，gitサーバ(origin)にアップロードする。\n$ git add \u003c更新したファイル名\u003e $ git commit -m “修正点を少し書く” \u003c=ローカルリポジトリ(手元)に登録 $ git push origin main \u003c=リモートリポジトリに反映 とりあえず，これで最低限のファイル共有/共同編集はできる。\ngit addは，更新したファイルのうち，リモートリポジトリに反映したいファイルを指定(stagingとよぶ。これにより対象ファイルはstaging areaに移動)する。指定方法は以下のようにいろいろある。\n$ git add . 新規作成ファイルと更新ファイルを全部指定 $ git add -u 前回から更新したファイルのみ指定(新規作成ファイルは含まない) $ git add -A .新規作成ファイル，更新ファイル，削除ファイル全部指定 ただし，リモートリポジトリは，知らないヒトが勝手に’git push’で書き換えたりできるとよくないので，アクセス制限をできるようになっている。アクセス制限がかかっているリモートリポジトリの内容の修正をリクエストするにはPullRequestをする(後述)。\ngitサーバでリポジトリを削除する方法 削除したいリポジトリのページに移動 上の一覧からSettingsをクリック 下の方にあるDelete this repositoryをクリック 警告を読んで、消したいリポジトリの名前を入力 I understand the consequences, delete this repositoryをクリック 参照 Qiita「githubでリポジトリを削除する方法」 ローカルリポジトリの削除(git initの取り消し) .gitファイルを削除して、git initしたディレクトリに対して、それを取り消す\n$rm -rf .git 参照 Qiita 「git init取り消し」 コミット履歴の確認 $ git log --graphというオプションをつけるとコミットログをアスキーアートでカラフルに表示シてくれる。たくさんブランチがあるリポジトリなどでは見やすくなる\n$ git log --graph コミットのキャンセル ステージングのキャンセル ステージング(git add)から変更ファイルを取り消す場合は下記コマンドを実行します。\n$ git rm --cached \u003cファイル名\u003e ステージング(git add)から削除するだけでなく、ファイル自体も削除する場合には下記コマンドを実行します。\n$ git rm -f \u003cファイル名\u003e コミットの取り消し 直前に行ったコミットを取り消すには下記コマンドを実行します。\n作業ディレクトリの内容はコミット時のままで、「コミットした」ということだけが取り消されます。\n「–soft」オプションは省略できます。\n$ git reset [--soft] HEAD^ 作業ディレクトリに加えた変更点もコミット前に戻す場合は以下のコマンドです。\n$ git reset --hard HEAD^ 作業ディレクトリをローカルリポジトリの最新状態にするには下記コマンドを実行します。\nindexもクリーンされます。\n$ git reset --hard HEAD コミット後の修正 前回のコミットを破棄して、現在のIndex内容で新しくコミットします。\n「reset」と「commit」を実行することと同様の処理となります。\nコミットメッセージの修正なども行えます。\n$ git commit --amend 参照 Camp Netwoek「Gitローカルリポジトリ操作」 プッシュの取り消し 基本、プッシュした情報をローカルリポジトリに戻すことはできない。 そこで、コミットを打ち消すコミットを生成する（git revertコマンド）。プッシュ済みのコミットを消す方法もあるが、よくなさそう。。git revertでは打ち消したコミットの記録が残る。\ngit revert 指定したコミットを、add前に戻してくれるコマンド。\nターミナル(間違って、masterにpushしちゃった時など)\n% git log # コミットログの確認 % git revert 間違えたコミットID # 指定したコミットを、add前に戻す # ターミナルが編集できなくなるので、`:q`で脱出 GitHub Desktopを確認すると、git revertで生成したコミットが生成されてるハズ。これをpushすれば、リモートリポジトリで打ち消されているハズ。この時、ローカルからも消えるので、注意。 参)ターミナルで実施する場合\n% git pull # 念のため、ローカルのmasterを最新にする % git checkout pushすべきだったブランチ # ブランチを切り替える % git merge master % git add . # 変更箇所をadd % git commit -m \"コミットメッセージ\" % git push origin pushしたかったブランチ ※ 念のため、ローカルのmasterをpull(最新)にしてから、作業してたブランチも最新状態をmerge(反映)し、pushすべきだったブランチにpushするイメージ。\nその他のコマンド よく使用するコマンド コマンド 概要 git init 対象のディレクトリをバージョン管理できる入れ物に格納してくれるイメージ git add ●● ●●をインデックスに追加。※ git add . とすると「全て」を対象にできる git commit -m ‘メッセージ’ コミット git status 現在のファイルの状態(staging等)一覧を表示する git reset \u003cファイル名\u003e 間違えてgit addしたファイルの取り消し(stagingの取り消し) git log コミットログの履歴確認（コミットID、コミットメッセージ、日時） git remote add origin リモートリポジトリのURL(https：//github.com/GitHubのユーザー名/リモートリポジトリ名.git) ローカルリポジトリにリモートリポジトリの情報を付与し、紐づける git push origin ブランチ名 ローカルの変更点を、リモートに反映。ブランチ名 masterなら、マスターブランチにプッシュ。 git pull origin master リモートリポジトリ（origin）のマスターブランチをローカルリポジトリに反映。 git clone https：//github.com/ユーザー名/リモートリポジト名.git リモートリポジトからローカルリポジトリにダウンロード git remote -v ローカルにクローンしたリポジトリのリモートURL確認方法 コミットメッセージ例 コミットメーセージ 意味 Create ●● class クラス作成 Add relation with ●● リレーションの追加 Add presence validation of ●● バリデーションの追加 Add #parse_body for parse body’s markdown - 参照 上記にも記入済み Qiita「githubでリポジトリを削除する方法」 Qiita 「git init取り消し」 Camp Netwoek「Gitローカルリポジトリ操作」 その他 Qiita「GitとGitHubの基礎」 Qiita「ローカルgitリポジトリでリモートのリポジトリURLを確認する方法」 Qiita「【GitHub】アカウント名を変更するときの注意点 ",
    "description": "",
    "tags": null,
    "title": "Repository Operations",
    "uri": "/watanuki/github/repository-edit/index.html"
  },
  {
    "content": "コミットの取り消し 直前のコミットの取り消し $ git reset \u003c打ち消したいコミットID\u003e 直前のコミットを打ち消す場合には以下のコマンドを使用\n$ git reset --soft HEAD^ --softオプション：ワークディレクトリの内容はそのままでコミットだけを取り消したい場合に使用 --hardオプション：コミット取り消した上でワークディレクトリの内容も書き換えたい場合に使用 HEAD^: 直前のコミットを意味 HEAD~{n}n個前のコミットを意味 コミットの打ち消し $ git revert \u003cコミットのハッシュ値\u003e 作業ツリーを指定したコミット時点の状態にまで戻し、コミットを行う。\nコミットの上書き 直前のコミットに上書きする場合は以下のコマンドを使用\n$ git commit --amend リモートリポジトリからのみ特定のファイルを削除 git rm --cached \u003ctarget file\u003e ディレクトリを削除する場合は\n$ git rm --cached -r \u003ctarget directory\u003e reference [Git]コミットの取り消し、打ち消し、上書き 【Git入門】git commitを取り消したい、元に戻す方法まとめ Gitのリモートリポジトリから特定のファイルを削除する方法 ",
    "description": "",
    "tags": null,
    "title": "About resetting commit and rm the file",
    "uri": "/watanuki/github/commit/index.html"
  },
  {
    "content": "公開鍵を GitHub に登録することで、push 時などにパスワードを入力する手間が省略可能 公開鍵および秘密鍵の作成と登録 公開鍵および秘密鍵を作成\nssh-keygen -t ed25519 公開鍵 を GitHub に登録\ncat ~/.ssh/id_ed25519.pub # コマンドを実行して表示されたすべての文字列を GitHub に登録 # # ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX user@host # ↑こんな感じの文字列をすべてコピペ GitHub の公開鍵登録の手順は、\nSettings SSH and GPG keys [New SSH key] タイトルをつけ公開鍵をコピペし [Add SSH key] SSH の設定 GitHub で使用する秘密鍵を設定するため、~/.ssh/config に設定を記述\n最終行 (ProxyCommand の部分) は学内のコンピューターの場合にのみ設定\n接続の確認 $ ssh -T git@github.com ターミナルで実行して以下のように表示されればOK!\nHi (User名)! You've successfully authenticated, but GitHub does not provide shell access. ※途中で以下のプロンプトメッセージが表示されたらyesと入力 The authenticity of host '[ssh.github.com]:443 (\u003cno hostip for proxy command\u003e)' can't be established. RSA key fingerprint is [以下省略]. Are you sure you want to continue connecting (yes/no/[fingerprint])? The authenticity of host '[ssh.github.com]:443 (\u003cno hostip for proxy command\u003e)' can't be established. RSA key fingerprint is [以下略]. Are you sure you want to continue connecting (yes/no/[fingerprint])? ssh接続がうまく行かないとき レポジトリのディレクトリに入り次のコマンドを入力\ngit config remote.origin.url https://github.com/[ユーザID]/[リポジトリ]となっていたらレポジトリのディレクトリ内の/.git/configを開いてurlの覧を\nurl = github.com:[ユーザID]/[リポジトリ].git と書き換える。\nまたは以下のコマンドを実行\ngit remote set-url origin [Host名]:[ユーザID]/[リポジトリ].git ※~/.ssh/configで設定していない場合は\ngit remote set-url origin git@github.com:[ユーザID]/[リポジトリ].git でOK!\n参照 Qiita「Githubでssh接続する手順」 GitHubヘルプを参考にSSHキーの設定を行ってみた\n",
    "description": "",
    "tags": null,
    "title": "Public key authentication settings in github",
    "uri": "/watanuki/github/ssh/index.html"
  },
  {
    "content": "ファイルの変更差分の確認 $ git diff [変更前のコミット識別子]..[変更後のコミット識別子] ブランチ同士の差分の確認 $ git diff master..develop masterブランチにプルリクエストを送る前にdevelopブランチに追加した内容を確認できる\ngit pull する前に、リモート追跡ブランチとの差分を確認する リモートリポジトリからの変更内容の取得 $ git fetch origin ローカルリポジトリのmasterブランチの最新コミット(HEAD)とリモート追跡ブランチ(origin/master)を比較 $ git diff HEAD..origin/master git push する前に、リモート追跡ブランチとの差分を確認する $ git diff origin/master..HEAD 参考 第9話 git diff で差分を確認！【連載】マンガでわかるGit ～コマンド編～ ",
    "description": "",
    "tags": null,
    "title": "Confirmation of difference",
    "uri": "/watanuki/github/diff/index.html"
  },
  {
    "content": "ブランチとは？ ブランチとは平行世界のようなものである。 ブランチを活用することでmasterブランチをそのまま据え置いた状態で、別のブランチで新機能を試しながら作ることができる。\nブランチの正体は？ github公式ドキュメントによると、\nブランチとは（中略）コミットを指す軽量なポインタに過ぎません と説明されている。\nリポジトリの正体は.gitという隠しフォルダのことであり、この中にあるrefs/heads/masterファイルこそがブランチの正体である。 このファイルの中身をcatしてみると\ndd95ddf066d452949bb54304bbf43ab3dadfee25 のように英数字の羅列が保存してある。これはコミットIDまたはコミットハッシュ値と呼ばれている。またコミットによって生成されたデータのことをコミットオブジェクトといい、一つのコミットオブジェクトに対して４０文字のIDを割り当てるのがコミットIDである。\nつまりブランチとはただ単に特定のコミットIDを指しているだけである。\nまたコミットオブジェクトにはそれぞれ\ntree parent author committer の情報が保存されており、parentが一つ前のコミットIDを示している。\n例 作成したsample.txtに何かしらの変更を加え、\n$ git add sample.text $ git commit -m \"2回目のコミット\" $ git log とすると、次のような結果が得られる。\nこのとき以下のように実行すると、コミットオブジェクトを確認することができる\n$ git cat-file -p 0e9556 tree e290b48b356d721ae54d1edb03993802cc98bad8\nparent 02f11b759bfeb461e117c5da18bb2dcbe06d862a\nauthor llminatolllXXX@mail.coml1562052826 +0900\ncommit errllminatolllXXX@mail.coml1562052826 +0900\nこのparentの部分が前のコミットのコミットIDを表しており、一番はじめのコミットではpaerntは保存されていない\nひとことメモ　** コミットIDは何を元に作られているの？** コミットID（コミットハッシュ値）は、実はこのコミットオブジェクトのバイト数と中身を使い、計算されて作られています。よって、コミットした人の名前やコミットした時間、指し示すparent、treeが違えばコミットハッシュ値も違うものになります。\nその証拠に、同じ内容をコミットしていても、あなたの練習用リポジトリとわかばちゃんのコミットIDは違うはずです。コミットハッシュ値についてもっと深く知りたい方は、こちらの記事が詳しいのでおすすめです。\nGitのコミットハッシュ値は何を元にどうやって生成されているのか ブランチの操作 今存在するブランチの確認\n$ git branch ※アスタリスクのついているブランチが現在のブランチ\nブランチの作成\n$ git branch \u003cbranch name\u003e ローカルブランチの作成をリモートにプッシュ\n$ git push origin \u003cbranch name\u003e ブランチの移動\n$ git checkout \u003cbranch name\u003e ※指定したブランチへ移動する\n-bオプションを指定するとブランチの作成とチェックアウトを同時に行える -fオプションを指定するとブランチを強制的に切り替えることができる（コミットしていない作業データは消えるため注意) リモートブランチの反映\n$ git fetch origin ブランチの削除\n$ git branch -d \u003cbranch name\u003e # ローカルブランチの削除(強制削除する場合は`-D`オプションに変更) $ git push origin --delete \u003cbranch name\u003e # リモートブランチの削除(`$ git push origin :\u003cbranch name\u003e` でも可) remote には存在するブランチが local には存在しない場合\n$ git brantch -a でブランチを表示\n$ git checkout -b release origin/release で解決できる! 参考 第2話 ブランチとは？ポインタってどういう意味？作成・確認・切り替え方法【連載】マンガでわかるGit ～コマンド編～ Git Branch コマンド リモートブランチの更新が見えない時 ",
    "description": "",
    "tags": null,
    "title": "Branch",
    "uri": "/watanuki/github/branch/index.html"
  },
  {
    "content": "ローカルリポジトリの作成 リモートリポジトリに登録したいディレクトリにして次のコマンドでバージョン管理のための初期化を行う。\n$ git init これで，ローカルリポジトリ(.git/)が作られ，git initを実行したディレクトリが作業ディレクトリになる。\n以下のようにgit initでローカルリポジトリ用のディレクトリを新規作成することもできる。\n$ git init \u003ctarget directory\u003e $ cd \u003ctarget directory\u003e .gitignoreの作成 gitコマンドでは無視したいファイルが有る時(LaTeXの一時ファイル等)は，.gitignoreという名前のファイルを作っておく。 以下は例。latex関連の一時ファイルを無視するように設定している。\n$ cat .gitignore *.aux *.idx *.log *.toc *.ist *.bbl *.blg *.dvi *.ilg *.ind *.lot *.out *.synctex.gz *~ ローカルリポジトリに登録するファイルやディレクトリの指定 下記のいずれかのコマンドで登録するファイルやディレクトリを指定\n$ git add . # 現在のディレクトリにある全てのファイル/ディレクトリを登録 $ git add figures/ # ディレクトリ figures/ 以下のファイルを登録 $ git add *.tex # すべての .tex ファイルを登録 $ git add \u003cファイル名\u003e #特定のファイルのみを登録 ローカルリポジトリにファイル登録 git addで指定したファイルやディレクトリを，ローカルリポジトリに登録する。\n$ git commit -m \"first commit\" -mは1行コメントをつけるオプション。 更新したファイルをローカルリポジトリに反映するときにも，同様にgit addとgit commitを実行する。ここまではローカルリポジトリの管理。\ngitサーバ上で新規リモートリポジトリを登録 GitHubにログイン\n左上のRepositoriesの隣りにあるNewのタブをクリック\nrepository作成ページで以下のことを記入\nRepository name : リポジトリの名前 Description : リポジトリの内容 Public / Privateの選択 Create repositoryをクリック\nリポジトリ作成後のすべきこと（コマンドライン）が記載されたページが表示されるので、URLの覧をチェックしておく。以下はその一例。\necho \"# re\" \u003e\u003e README.md git init git add README.md git commit -m \"first commit\" git branch -M main git remote add origin https://github.com/\u003cユーザーネーム\u003e/\u003crepository名\u003e.git git push -u origin main コマンドラインの上にHTTPSかSSHかを選択する覧もあるので、SSHにする場合はここで選択しておく\n参照 ITmedia 「Git/GitHubにおけるリモートリポジトリの作成、確認、変更、更新時の5コマンド」 SAMURAIENGINEER 「【Git初心者向け】リポジトリの作成からpushまで」 トークンの作成 2021年8月13日以降、GitHubのリポジトリにアクセスするには、ユーザ名とパスワードではなくアクセストークンが必要になった。\nGitHubにログイン 右上のアイコンをクリックし、一覧からSettingsをクリック 左下のDeveloper settingsをクリック 左の覧からPersonal avvess tokensをクリック 右上のGenerate new tokenをクリックしてアクセストークンを作成 以下のことを記入 Note : トークン名 Expiration : トークンが使用できる期限。この期限が切れると新しくトークンを作成する必要がある。（上限あり） Select scopes : 少なくともrepoの覧はチェックを入れること。 トークンは一度ページを移動すると二度と見れなくなってしまうため、作成後はコピーして保存しておくこと！！！ 参照 アクセストークンの作成方法 Qiita「アクセストークンとSSH接続について」 Gitサーバへの登録 ローカルリポジトリとgitサーバ上のリモートリポジトリの紐付け ローカルリポジトリ(要はgit管理したいプログラム群のあるディレクトリ)をgitサーバ上のリモートリポジトリと紐付ける。リモートリポジトリを作成した際に表示されたすべきこと（コマンドライン）を順次実行していく。 以下はその一例。\ngit branch -M main git remote add origin https://github.com/\u003cユーザーネーム\u003e/\u003crepository名\u003e.git git push -u origin main ただしURLの覧にはhttps://とgithub.com/...の間に\u003cトークン\u003e@を加えて実行する。\n$ git remote add origin https://\u003cトークン\u003e@github.com/\u003cユーザーネーム\u003e/\u003crepository名\u003e.git ユーザーネームとパスワードを求められたらユーザーネームには自分の登録名、パスワードにはトークンを打ち込む\ngit remoteは，サーバ上のファイル置き場(リモートリポジトリ)を登録する命令。 この例では，URL(https://github.com/\u003cユーザーネーム\u003e/\u003crepository名\u003e.git)を，originという名前(識別子)で登録している。 識別子 origin は他の名前にしても良いが，慣習的にこの名称が使われている。 someone/somerepoの部分は，GitHub上に作ったリポジトリの名前に従って設定する。\nただし，非公開リポジトリ(private repository)に登録する場合は，以下のようにGitHubの認証情報を加える。\n$ git remote add origin https://\u003cusername\u003e@github.com/s\u003cユーザーネーム\u003e/\u003crepository名\u003e.git セキュリティを高めるためには，ssh keyをGitHubに登録しておいて，ssh通信にするほうが無難。この場合のgit rmoteは以下のなる。\n$ git remote add origin git@github.com:someone/somerepo.git 登録情報の確認 $ git remote -v 登録情報を間違えていたら，以下のコマンドで一旦削除して再登録する\n$ git remote rm origin ",
    "description": "",
    "tags": null,
    "title": "How to Create Repository",
    "uri": "/watanuki/github/create-repository/index.html"
  },
  {
    "content": "アカウントの作成 GitHubのホームページでアカウントを作成する\npro版（GitHub Education)への変更方法 GitHub Educationにアクセス 右上のBenefitsをクリック IndividualsのGet student benefitsを選択 申し込むための資格が書いてあります。 学生であること。 学校からもらったメアドがあること。 GitHubアカウントを持っていること。 13歳以上であること。 Screenshot from 2020-09-23 15-02-45.png Add an email addressから学校のアドレスを追加 How do you plan to use GitHub?にgithubの利用目的を記入 Submit your informationを押して完了 ※利用目的は形式的なものなので（多分）適当に書いてOK! 参考ページ Qiita , @Kobayashi2019「GitHub Educationのメリットと申請方法」\ngitコマンドのインストール git コマンドをローカルマシンにインストールする。 Mac OSの場合は，Xcode コマンドラインツールをインストールしていたら，gitコマンドもインストールされている。\napt-get対応のLinuxディストリビューションなら以下でたいていOK。\n$apt-get install git 自分のアカウント情報のローカルマシンへの登録 $git config --global user.name \u003cユーザーネーム\u003e $git config --global user.email \u003c登録したメールアドレス\u003e $git config --global core.editer vi #コメント編集につかいたいエディタを設定（デフォルトはvi） --globalは，ローカルリポジトリ作成時のデフォルト設定にするためのオプション。 特定のリポジトリでのみ別の設定にしたいときには，ダウンロードしたポジトリ内に移動してから--localを指定して実行する。\n必要に応じてproxy設定 外部とのネットワーク接続にproxy設定が必要な環境の場合は，Proxy設定のページを見て設定をする。ターミナルとgitのproxy設定をする。\ngit pull するたびに警告が出る… Git2.27での git pull 時の warning について ",
    "description": "",
    "tags": null,
    "title": "Settings",
    "uri": "/watanuki/github/settings/index.html"
  },
  {
    "content": "Docker のインストール後の設定 docker group に追加 Docker サービスをデフォルトで起動時に開始するように設定 $ sudo systemctl enable docker.service $ sudo systemctl enable containerd.service 無効化は以下の通り\n$ sudo systemctl disable docker.service $ sudo systemctl disable containerd.service インストール後の設定はこちら\n",
    "description": "",
    "tags": null,
    "title": "Post Installation Steps for linux",
    "uri": "/watanuki/docker/post-installation-step/index.html"
  },
  {
    "content": "docker での copy と mount コピー ホストとコンテナ間でファイルをコピーするときは次のようにする\n$ docker cp \u003coption\u003e \u003cコピー元path\u003e \u003cコピー先path\u003e コンテナのパスは\u003ccontainer name\u003e:\u003cpath\u003eのように書く\nマウント ※マウントはコンテナをrunするときにオプションとして指定する\nバインドマウント 既存（ホスト側）のファイルやフォルダをマウントする方法のこと。\n普通のファイル同様に編集やバックアップが可能となるため、頻繁にアクセスするファイルなどはこちらに置く。\n$ docker run (省略) -v \u003cマウント元のパス\u003e:\u003cマウントポイント\u003e (省略) ボリュームマウント ボリュームを作成し、マウントする方法のこと。\nDockerホストから変更を加えたくないようなファイルなどはこちらに置く。\nボリュームの作成\n$ docker volume create \u003cvolume name\u003e ボリュームの削除\n$ docker volume rm \u003cvolume name\u003e マウント方法\n$ docker run (省略) -v \u003cボリューム名\u003e:\u003cマウントポイント\u003e (省略) ※ただしボリュームが存在しないときには新規作成される。\ndocker volume コマンドにおけるサブコマンド\nサブコマンド 意味 create ボリュームの作成 inspect ボリュームの詳細情報を確認 ls ボリューム一覧を確認 prune コンテナからマウントされていないボリュームをすべて削除 rm ボリュームの削除 ボリュームマウントとバインドマウントを明示的に指定した設定方法 $ --mount type=\u003cbind or volume\u003e,src=\u003cマウント元\u003e,dst=\u003cマウント先\u003e ※この方法ではバインドマウントとボリュームマウントが明示的に指定されているためわかりやすく、 ボリュームが存在しない場合には新規作成されずエラーが出力される。そのため-vオプションより --mountオプションを使用することが推奨されている。\nsrc は source でもOK dst は destination でもOK type=tmpfs としてメモリーを特定のマウント先に指定することもできる。 appendix ボリュームのバックアップ方法 $ docker run --rm -v \u003cvolume name\u003e:/src -v \u003cバックアップ先のフォルダ名\u003e:/dest busybox tar czf /dest/backup.tar.gz -C /src . 軽量なLinux イメージの busybox を起動 バックアップ対象をコンテナの /src にボリュームマウント Docker ホストの任意のディレクトリを /dest にバインドマウント /src 以下の全ファイルが /dest/backup.tar.gz にバックアップされる コンテナが破棄される ※ただしこの方法ではバックアップしたいボリュームのボリューム名がわかっていなければならない。 バックアップ対象をボリューム名ではなくコンテナのディレクトリ名で指定したい場合は--volume-fromオプションを使用する！\n$ docker run --rm --volume-from \u003ccontainer name\u003e -v \u003cバックアップ先\u003e:/dest busybox tar czf /dest/bachup.tar.gz -C /var/lib/mysql . バックアップのリストア バックアップを取っておいたデータを任意のvolumeに復元する方法\n$ docker run --rm -v \u003cvolume名\u003e:/dest -v \u003cバックアップデータの置かれているディレクトリ\u003e:/src busybox tar xzf /src/backup.ta.gz -C /dest データボリュームコンテナ ",
    "description": "",
    "tags": null,
    "title": "Copy and Mount from Docker container or to Docker container",
    "uri": "/watanuki/docker/copy-mount/index.html"
  },
  {
    "content": "1. Dockerのインストールの仕方 古いバージョンをアンインストール\n$ sudo apt-get remove docker docker-engine docker.io containerd runc It’s OK if apt-get reports that none of these packages are installed.\n1.1 Install methods Dockerのリポジトリをセットアップしてそこからインストール方法が推奨されている。\n異なる方法もあるが、ここではリポジトリからインストールを行う。\nリポジトリの設定\n$ sudo -E apt-get update $ sudo apt-get install \\ ca-certificates \\ curl \\ gnupg \\ lsb-release Dockerの公式GPGキーを追加\n$ sudo mkdir -p /etc/apt/keyrings $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg 次のコマンドを使用して、リポジトリを設定\n$ echo \\ \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list \u003e /dev/null 1.2 DockerEngineのインストール aptパッケージインデックスを更新し、Docker Engine、containerd、Docker Composeの最新バージョンをインストールするか、次の手順に進んで特定のバージョンをインストールする $ sudo apt-get update $ sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin Docker Engineの特定のバージョンをインストールするには、リポジトリに使用可能なバージョンをリストしてから、以下を選択してインストールを行う リポジトリで利用可能なバージョンを一覧表示\n$ apt-cache madison docker-ce たとえば、2番目の列のバージョン文字列を(5:20.10.16~3-0~ubuntu-jammy)使用して特定のバージョンをインストールするならば、次のようなコマンドを実行する\n$ sudo apt-get install docker-ce=5:20.10.13~3-0~ubuntu-hirsute docker-ce-cli=5:20.10.13~3-0~ubuntu-hirsute containerd.io docker-compose-plugin 1.3 proxyの設定 Docker Engine の proxy 設定 docker pull などでイメージを落としてくる場合はDocker Engine にプロキシ設定をする必要がある。\n/lib/systemd/system/docker.serviceで環境変数を指定。[Service]の欄の下にEnvironmentを追記すればOK！\n[Service] Environment=HTTP_PROXY=http://{HOST}:{port} Environment=HTTPS_PROXY=http://{HOST}:{port} Docker コンテナ起動時の proxy 設定 ~/.docker/config.json を書いておくとコンテナ内に HTTP_PROXY などを自動で設定してくれる\n※Docker Compose のときにはつかえない？\n{ \"proxies\": { \"default\": { \"httpProxy\": \"http://{HOST}:{port}\", \"httpsProxy\": \"http://{HOST}:{port}\" } } } proxy設定の反映とDockerを再起動\n$ sudo systemctl daemon-reload $ sudo systemctl restart docker やってみたけどあまり意味のなかった設定 upstartの人\n$ sudo cat /etc/default/docker （省略) export no_proxy='export no_proxy=127.0.0.1,localhost,xxx.xxx.xxx.xxx' export NO_PROXY=\"${no_proxy}\" export http_proxy='http://your.proxy.url:port/' export HTTP_PROXY=\"${http_proxy}\" export https_proxy='https://your.proxy.url:port/' export HTTPS_PROXY=\"${https_proxy}\" Systemdの人\n$ sudo cat /etc/systemd/docker.service （省略） [Service] Environment=\"HTTP_PROXY=http://your.proxy.url:port/\" \"HTTPS_PROXY=https://your.proxy.url:port/\" ※　/lib/systemd/system/docker.serviceと併用しようとするとDockerが起動しなくなるので注意！2つの設定が競合するのかな？\ndocker.service.dにファイルの追加\n$ cd /etc/systemd/system/ $ mkdir docker.service.d $ sudo nano http-proxy.conf -\u003e 内容の書き込み $ cat /etc/systemd/system/docker.service.d/http-proxy.conf [Service] Environment=\"HTTP_PROXY=http://proxy.example.com:8080/\" Environment=\"HTTPS_PROXY=http://proxy.example.com:8080/\" 1.4 確認 hello-worldイメージを走らせ、Dockerが正しくインストールされていることを確認 $ sudo docker run hello-world 2. Dockerのアンインストール方法 Docker Engine、CLI、Containerd、およびDockerComposeパッケージをアンインストール\n$ sudo apt-get purge docker-ce docker-ce-cli containerd.io docker-compose-plugin ホスト上のイメージ、コンテナー、ボリューム、またはカスタマイズされた構成ファイルは自動的に削除ない。すべてのイメージ、コンテナー、およびボリュームを削除するには下記を実行\n$ sudo rm -rf /var/lib/docker $ sudo rm -rf /var/lib/containerd ※編集した構成ファイルは手動で削除する必要がある\n3. 問題とその解決策 3.1 $ sudo docker run hello-worldを実行するとタイムアウトしてしまう インターネットに接続できない -\u003e proxyを設定（上記参照）\nproxy 設定してもDockerイメージが取得できない(conectできない)… おそらく公開鍵の問題！\napt updateなどを実行すると、「公開鍵を利用できないため、以下の署名は検証できませんでした」というエラーが出る。\nつまりGPGエラーが問題だった！\nということでOpenGPG鍵をインポート\n$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-k DockerのインストールでもGPG鍵キーのインストールはしているが、おそらく以下のどちらかが問題だった…\nInstall methodの 2. でもインストールしてるけどetcのところをusrにしなければならなかった 1.2 DockerEngineのインストールはどちらも実行してしまい、DockerイメージをダウングレードしてしまったためGPGエラーが起こった（？） 補足（やってみたけど意味のなかったこと） GPGエラーについて\nW: 署名照合中にエラーが発生しました。 リポジトリは更新されず、過去のインデックスファイルが使われます。 GPG エラー: http://packages.cloud.google.com/apt cloud-sdk-xenial InRelease: 公開鍵を利用できないため、 以下の署名は検証できませんでした: NO_PUBKEY 6A030B21BA07F4FB\nと出力されたため、apt-keyコマンドでパブリックキーを追加した（パブリックキーの有効期限切れだと思った…）\n$ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 6A030B21BA07F4FB -\u003e apt-keyではproxyにうまく接続できない問題が発生…\n-\u003e --keyserver-optionを使用してproxyサーバを指定\n$ sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --keyserver-option http-proxy=http://x:y@proxy:port --recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9 Executing: gpg --ignore-time-conflict --no-options --no-default-keyring --secret-keyring /tmp/tmp.oqJcUg9wwq --trustdb-name /etc/apt/trustdb.gpg --keyring /etc/apt/trusted.gpg --primary-keyring /etc/apt/trusted.gpg --keyserver hkp://keyserver.ubuntu.com:80 --keyserver-option http-proxy=http://x:y@proxy:port --recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9 gpg: 鍵A88D21E9をhkpからサーバーkeyserver.ubuntu.comに要求 gpg: 鍵A88D21E9: 公開鍵“Docker Release Tool (releasedocker) \u003cdocker@dotcloud.com\u003e”を読み込みました gpg: 処理数の合計: 1 gpg: 読込み: 1 (RSA: 1) 3.2 インターネットに（ブラウザで）接続できない proxyの設定とGPG鍵のインストールで$ sudo docker run hello-worldは実行できるようになったが、未だChromeやFireFoxが使えない（インターネットに接続できない）…\ndocker ではUbuntuの以下4つのバージョンでしか正常に動作することが保証されてなかったため、Ubuntu21.04ではうまく行かなかった\nUbuntu Jammy 22.04 (LTS) Ubuntu Impish 21.10 Ubuntu Focal 20.04 (LTS) Ubuntu Bionic 18.04 (LTS) 22.04 に upgrade したら使えるように！　→ Ubuntu22.04 のproxy設定を手動にしたら使えるようになった！\n参考 Dockerのインストール Docker Engine インストール（Ubuntu 向け） Install Docker Engine on Ubuntu Installation Guide(NVIDIA) proxy設定 プロキシ環境下の Docker Proxy環境でdockerを外に繋ぐ方法 プロキシサーバを使うように Docker を設定 プロキシーサーバー利用の設定 Ubuntu 18.04 LTS / 20.04 LTS に Docker をインストールする 問題 GPGエラーについて GPGエラーの解決策（「apt-key が非推奨になったので」 【Ubuntu】 apt update時のGPGエラー対処 ubuntuで認証プロキシ配下からapt-keyを使うとき ",
    "description": "",
    "tags": null,
    "title": "How to install Docker",
    "uri": "/watanuki/docker/installation-docker/index.html"
  },
  {
    "content": "docker の cuda コンテナの追加設定 1. .bashrc の変更 /home/ と /root/ 以下に保存 /home/ はボリュームマウントしているので、新しくコンテナを作成する場合は設定ファイルを /home/ の保存し、作成したコンテナで /home/ 以下の設定ファイルをコピーすること！ 2. python のライブラリの追加 ライブラリを追加するディレクトリにパスを通す\n$ export PYTHONPATH=\"/root/.local/lib/python3.8/site-pachages/:$PYTHONPATH\" moysnn ライブラリのシンボリックリンクを\"/root/.local/lib/python3.8/site-pachages/“以下に作成 3. コマンドのインストール tree trash ",
    "description": "",
    "tags": null,
    "title": "Docker Container for Cuda",
    "uri": "/watanuki/docker/container-cuda/index.html"
  },
  {
    "content": "dockerでsshを行う場合にはopensshd-serverをインストールし、設定を行う必要がある。\nsettings.sh\nexport DEBIAN_FRONTEND=noninteractive apt-get install -y openssh-server export mkdir /var/run/sshd export ENV=NOTVISIBLE \"in users profile\" echo \"export VISIBLE=now\" \u003e\u003e /etc/profile echo \"service ssh start\" \u003e\u003e /etc/profile Dockerfile\nRUN bash /tmp/setting.sh EXPOSE \u003cport\u003e CMD [\"/usr/sbin/sshd\", \"-D\"] ただしssh-serverが起動していなければ接続できない。そのため、コンテナ内で以下のコマンドを使用し、サーバーが止まっていないかを確認すること。\n$ service ssh status start or stop ssh $ service ssh start $ service ssh stop trouble 何度もuser名などを変えているとssh接続できない… known_hostsファイルの情報と異なるためsshできなくなる\n$ ssh-keygen -f \"\u003cpath of known-hosts file\u003e\" -R \"[\u003chost\u003e]:\u003cport\u003e\" と実行すればOK! (log標準出力でも表示されるのでそちらを参照！）\n詳しくはこちら 参照 docker 「コンテナを ssh 接続できるようにするDockerfile」チュートリアル解説 Docker Ubuntu18.04でtzdataをinstallするときにtimezoneの選択をしないでinstallする はじめてのLinux(CentOS)サーバ構築 〜SSH接続、IP制限〜 「SSHホスト鍵が変わってるよ！」と怒られたときの対処 ",
    "description": "",
    "tags": null,
    "title": "Connect to Docker Container via ssh",
    "uri": "/watanuki/docker/container-ssh/index.html"
  },
  {
    "content": " update $ sudo apt update $ sudo apt upgrade file のダウンロード $ sudo curl -L \"https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose 権限の付与 $ sudo chmod +x /usr/local/bin/docker-compose 動作確認 $ docker-compose --version docker compose のアップグレード docker compose の v1 系をインストールしてしまっていたので v2 系にグレードアップ\n1系のDocker compose の削除 /usr/local/bin/にあるdocker-composeディレクトリを削除\n$ sudo trash docker-compose 新しいDocker compose のインストール 以下のコマンドを実行して Docker Compose の現時点での最新安定版をダウンロードします。\n$ DOCKER_CONFIG=${DOCKER_CONFIG:-$HOME/.docker} $ mkdir -p $DOCKER_CONFIG/cli-plugins $ curl -SL https://github.com/docker/compose/releases/download/v2.4.1/docker-compose-linux-x86_64 -o $DOCKER_CONFIG/cli-plugins/docker-compose このコマンドによって、アクティブユーザーの$HOMEディレクトリ配下に Compose がインストールされます。 システム上の全ユーザー向けに Docker Compose をインストールする場合は、~/.docker/cli-pluginsの部分を/usr/local/lib/docker/cli-pluginsに置き換えます。\n別のバージョンをインストールする場合はv2.4.1 の部分を書き換える\n実行バイナリに対して実行権限を与えます。\n$ chmod +x $DOCKER_CONFIG/cli-plugins/docker-compose インストール結果をテストします。\n$ docker compose version アンインストールする場合 curlを使って Docker Compose をインストールしていた場合は、次のようにしてアンインストールします。 $ rm $DOCKER_CONFIG/cli-plugins/docker-compose 参考 docker docs ",
    "description": "",
    "tags": null,
    "title": "How to install Docker Compose",
    "uri": "/watanuki/docker/instalation-docker-compose/index.html"
  },
  {
    "content": "dockerでcudaコンテナの作成 cuda の　GPG key 登録 古いキーの削除\n$ sudo apt-key del 7fa2af80 ヘルパーパッケージを利用したキーの登録 nvidia が提供している、nvidia リポジトリ用の新しい署名キーのインストールを自動化する新しいヘルパーパッケージを利用して鍵を登録\n$ wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2204/x86_64/cuda-keyring_1.0-1_all.deb $ sudo dpkg -i cuda-keyring_1.0-1_all.deb ※ubuntu2204とx86_64は該当のものに書き換える\nremove の仕方 ※インストール時にターミナルに表示された文\nA deprecated public CUDA GPG key appear to be installed. To remove the key, run this command: sudo apt-key del 7fa2af80 結局必要だったのかわからなかったけどとりあえずやったこと Setting up NVIDIA Container Toolkit パッケージリポジトリと GPG key のセットアップ\n$ distribution=$(. /etc/os-release;echo $ID$VERSION_ID) \\ \u0026\u0026 curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg \\ \u0026\u0026 curl -s -L https://nvidia.github.io/libnvidia-container/$distribution/libnvidia-container.list | \\ sed 's#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g' | \\ sudo tee /etc/apt/sources.list.d/nvidia-container-toolkit.list nvidia-docker2 パッケージのインストール\n$ sudo apt-get update $ sudo apt-get install -y nvidia-docker2 Docker demon のリスタート\n$ sudo systemctl restart docker ベースとなるCUDAコンテナを実行することによって、動作するセットアップをテスト\n$ sudo docker run --rm --gpus all nvidia/cuda:11.0.3-base-ubuntu20.04 nvidia-smi 以下のような出力ならOK！\n+-----------------------------------------------------------------------------+ | NVIDIA-SMI 450.51.06 Driver Version: 450.51.06 CUDA Version: 11.0 | |-------------------------------+----------------------+----------------------+ | GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. | | | | MIG M. | |===============================+======================+======================| | 0 Tesla T4 On | 00000000:00:1E.0 Off | 0 | | N/A 34C P8 9W / 70W | 0MiB / 15109MiB | 0% Default | | | | N/A | +-------------------------------+----------------------+----------------------+ +-----------------------------------------------------------------------------+ | Processes: | | GPU GI CI PID Type Process name GPU Memory | | ID ID Usage | |=============================================================================| | No running processes found | +-----------------------------------------------------------------------------+ containerd コンテナエンジンとしてcontainerdをシステムにインストールするために、いくつかの前提モジュールをインストール\n$ sudo modprobe overlay \\ \u0026\u0026 sudo modprobe br_netfilter これらを確実に持続させることができる\n$ cat \u003c\u003cEOF | sudo tee /etc/modules-load.d/containerd.conf overlay br_netfilter EOF apt が HTTPS 上でリポジトリを使用できるようにするためのパッケージをインストール\n$ sudo apt update $ sudo apt-get install \\ ca-certificates \\ curl \\ gnupg \\ lsb-release リポジトリとGPG key の追加\n$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/ docker-archive-keyring.gpg $ echo \\ \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list \u003e /dev/null ※1回やってたらいらないかも…\nDockerfile and docker-compose.yml の作成 docker compose と Dockerfileを使う場合 こちらを参照 コンテナ作成後の設定 鍵の作成 ssh server の起動 $ bash ./sterter.sh vscodeのsettings.jsonとkeyboard.jsonの設定 rootのパスワード設定 Dockerfile のみの場合 こちらを参照 trouble apt が使えない… コンテナにはproxyを通してたけどaptに通すのを忘れてた…\nDockerfile の apt update の前に以下の文を追加\nRUN echo 'Acquire::http::proxy \"http://proxy.cc.yamaguchi-u.ac.jp:8080\"; \\ Acquire::https::proxy \"https://proxy.cc.yamaguchi-u.ac.jp:8080\";' \u003e /etc/apt/apt.conf nvidia gpg key の更新 $ sudo apt-key del 7fa2af80 $ wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64/cuda-keyring_1.0-1_all.deb $ sudo dpkg -i cuda-keyring_1.0-1_all.deb $ sudo apt update cuda version を下げるとapt update が通らなくなる RUN apt-get update \u0026\u0026 apt-get install -y \\ bzr \\ cvs \\ git \\ mercurial \\ subversion みたいな感じで update と install をつなげてみたけどだめだった…\nnvidiaのドライバが使えなくなった… nvidia driverのバージョンを落としてインストールし直す nvidia container toolkitをインストール proxy設定 参照 Dockerhub nvidia/cuda NVIDA Installation Guide 【Docker】GPU が使える Jupyter Notebook 環境を最速で用意する NVIDIA Docker って今どうなってるの？ (19.11版) 西井先生のページ NVIDIA Container Toolkit (NVIDIA Docker) は何をしてくれるか Dockerfileのプロキシ設定 コンテナで Hello world docker上でjupyter-notebookを使用する方法 NVIDIA DockerイメージのGPGキー更新に関する備忘録 NVIDIAのリポジトリのキーが更新されました。（2022年4月28日） Dockerfile のベストプラクティス docker-composeで作成されるものの名前を明示的に指定する方法 CudaをDockerで使用する際のDockerfileの作成 次のようなDockerfileを作成する\nFROM nvidia/cuda:11.4.0-cudnn8-devel-ubuntu20.04 USER root COPY ./requirements.txt /tmp WORKDIR /code # ENV DEBIAN_FRONTEND noninteractive ENV https_proxy \"http://\u003cproxy server\u003e\" ENV https_proxy \"http://\u003cproxy server\u003e\" RUN echo 'Acquire::http::proxy \"http://\u003cproxy server\u003e\"; \\ Acquire::https::proxy \"https://\u003cproxy server\u003e\";' \u003e /etc/apt/apt.conf RUN apt-get update \u0026\u0026 apt-get install -y \\ curl \\ python3 \\ python3-distutils RUN curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py \u0026\u0026 python3 get-pip.py RUN pip install -r /tmp/requirements.txt proxy 設定は以下のようにする ENV https_proxy \"http://~~~\" ENV http_proxy \"http://~~~\" **cuda の　version を下げると apt update が通らなくなったので、RUN apt-get update 以下はコメントアウトして、 pythonなどはコンテナ作成後にアタッチしてインストールした… 同じ階層に requirememts.txt を作成し、 Dockerfile で呼び出せるようにする。 このファイルには必要なパッケージを記入しておく\njupyter jupyterlab numpy pandas matplotlib scikit-learn scikit-image scipy torch torchvision tqdm albumentations tensorflow-gpu Pillow opencv-python 作成したディレクトリ構造は次のようになる\n$ tree my-nvidia-cuda/ my-nvidia-cuda/ ├── Dockerfile ├── requirements.txt └── src └── test.ipynb Docker イメージをビルド\n$ cd my-nvidia-cuda $ docker build . -t \u003cimage name\u003e Docker コンテナを起動\n$ sudo docker run -it --gpus=all -v \"$PWD\":/code -p 8888:8888 --name \u003ccontainer name\u003e \u003cimage name\u003e /bin/bash --gpusはgpuのを列挙 ",
    "description": "",
    "tags": null,
    "title": "Docker Compose",
    "uri": "/watanuki/docker/docker-compose-cuda/index.html"
  },
  {
    "content": "systemctl の使い方 Docker の起動と停止 $ systemctl start docker.service $ systemctl stop docker.service $ systemctl stop docker.socket 設定の反映と再起動 $ systemctl deamon-reload $ systemctl restart docker.service docker コマンド $ docker \u003c上位コマンド\u003e \u003c副コマンド\u003e \u003cオプション\u003e \u003c対象\u003e \u003c引数\u003e option オプションの書式 内容 –name \u003cコンテナ名\u003e コンテナ名の指定 -p \u003cホストのポート番号\u003e:\u003cコンテナのポート番号\u003e ポート番号の指定 -v \u003cホストのディスク\u003e:\u003cコンテナのディレクトリ\u003e ボリュームのマウント –net=\u003cネットワーク\u003e コンテナをネットワークに接続 -e \u003c環境変数名\u003e=\u003c値\u003e 環境変数の指定 -d バックグラウンドで実行(detach: デタッチモードの略) -i コンテナに操作端末（キーボード）をつなぐ -t 特殊キーを使用可能にする -help ヘルプの表示 –rm コンテナ終了時に自動的にコンテナを削除する –workdir , -w コンテナ内部の作業ディレクトリを変更する Docker container の作成 $ docker run \u003coption\u003e \u003ccontainer image\u003e \u003c引数\u003e docker runコマンドは、イメージをダウンロードするdocker pull, コンテナを作成するdocker create, コンテナを起動するdocker startコマンドを一つにまとめたもの。\nコンテナを起動せずに作成したい(docker createしたい)場合などに, docker createとdocker startを分けて使用する。\nDocker 起動と停止 $ docker start \u003ccontainer name or container ID\u003e #container の起動(container ID は他と重複しない先頭数文字だけでOK！) $ docker stop \u003ccontainer name or container ID\u003e #container のストップ 便利なコマンド $ docker logs \u003ccontainer name\u003e #logの確認 container の破棄 $ docker container ls #起動中のコンテナの表示(`docker ps`のように省略可) $ docker container rm \u003ccontainer name\u003e #コンテナの削除(``docker rm`のように省略可) 起動していないコンテナをすべて削除する場合は\n$ docker container prune image の破棄 $ docker image ls #ダウンロードしたイメージ一覧 $ docker image rm \u003crepository\u003e:\u003ctag\u003e #imageの削除(※tag が latest という最新版を表す値の場合は省略可, `docker rmi` のように省略可) Docker の容量利用状況の確認 $ docker system df Build Cache の削除 $ docker builder prune ※キャッシュが貯まると容量を大量に食うので注意！\ndetachとattach detach Ctrl+P, Ctrl+Q\nattach\n$ docker attach \u003ccontainer name or containerID\u003e shellの実行 コマンド コンテナの状態 シェル終了時 docker run 停止時 コンテナ終了 docker exec 稼働時 稼働のまま 実行中のコンテナの場合\n$ docker exec -it \u003ccontainer name\u003e /bin/bash を実行することでシェルが起動する\n※ここでexitしてもdocker exec で実行したものが終了するだけのため、コンテナは終了しない\n停止中のコンテナの場合\n$ docker run --name \u003ccontainer name\u003e -it \u003cconteinaer image\u003e /bin/bash を実行することでシェルが起動する\n※ここでexitするとコンテナも終了する\n補足\nここではあくまで/bin/bashというコマンドを実行しているだけのため、/bin/passwd(パスワードの変更画面を表示)のような他のコマンドを実行することもできる。 他のシェルを使用したい場合には /bin/bash でなく /bin/sh/ のように実行することもできる 現在使用しているシェルはecho $SHELL, 使用可能なシェルはcat /etc/shellsで確認することができる。 ",
    "description": "",
    "tags": null,
    "title": "Basic docker usage",
    "uri": "/watanuki/docker/base/index.html"
  },
  {
    "content": "補足 1回限り動かすコンテナの使い方 （例）go言語でコンパイルするためのコンテナを作成する場合\n$ docker run --rm -v \"$PWD\":/usr/src/myapp -w /usr/src/myapp golang:1.13 go built -v ここではgo built -v を実行してコンテナを終了・削除している。\n",
    "description": "",
    "tags": null,
    "title": "Appendix",
    "uri": "/watanuki/docker/appendix/index.html"
  },
  {
    "content": "About calcuration of gradient How not to calculate gradient Use no_grad For example;\nwith torch.no_grad(): y = x*2 We can use as decorator\n@torch.no_grad() def doubler(x): return x*2 Use .detach() -\u003e ? Use .reaquires_grad -\u003e ? reference Pytorchの「.detach()」と「with no_grad():」と「.requires_grad = False」の違い PyTorchの新しい推論モードについて ",
    "description": "",
    "tags": null,
    "title": "Torch",
    "uri": "/watanuki/python/torch/index.html"
  },
  {
    "content": "pickleの使用方法 Saving with openでの保存、読み込み with open(\"filename.pkl\", \"wb\") as f: pickle.dump(data, f) with open(\"filename.pkl\", \"rb\") as f: hoge = pickle.load(f) pandasでの保存、読み込み import pandas as pd pd.to_pickle(data, \"filename.pkl\") hoge = pd.read_pickle(\"filename.pkl\") joblib(?)での保存、読み込み joblib.dump(data, \"filename.jb\", compress=3) hoge = joblib.load(\"filename.jb\") ",
    "description": "",
    "tags": null,
    "title": "Pickle",
    "uri": "/watanuki/python/pickle/index.html"
  },
  {
    "content": "Pandasの概要 pandasはデータ解析を容易にするPythonのサードパーティライブラリです。 データ構造に対して様々な処理を施す機能を提供しており、他のライブラリをバックエンドとして利用して連携して動作できることやデータに対する豊富な処理機能を備えていることから、高度なデータ解析に欠かせないツールとなっている。NumpyのようにC言語による実装であるため配列演算の高速化が図られている点も大規模データの扱いを容易にする魅力の一つとなっている。\nPyDataとは？ PyDataとはPythonによるデータ管理/分析ツールのユーザと開発者のコミュニティです。 PyDataで話題とされるPythonツール群を総称してPyData Stackなどと呼ぶ。\nPandasで何ができる？ Pndasはさまざまな形式で保存されたデータにアクセスし、効率的にそのデータを分析あるいは処理し、 その結果を可視化したり保存したりできるツールである。\nデータを入出力する機能(CSV, Excel, RDB/Relational DataBase, HDF5など) データを効率的かつ高速に処理できる形式でデータを格納 データのNaN（Not a Number、欠損値）処理 データの一部取り出しや結合 データの柔軟な変更やピボット(pivot)を処理 データに対する統計処理や回帰処理等 データの集約とグループ演算 Pandasのデータ型 pandasにはプログラムで作成したデータや外部から読み込んだデータを保持しておくデータ構造としてシリーズ、データフレーム、パネルの3つの形式があり、それぞれ1次元、2次元、3次元の配列に対応している。 また、それぞれのデータの位置または属性を表現するために行ラベル、列ラベル、アイテム名といったラベル名を設定する。\n1. Series 1次元データ保存用のデータ構造。格納するデータに制限はなく、すべての要素が同じデータ型である必要もない。\ndat = pd.Serie([1, 3, 6, 12]) dat2 = pd.Series(np.array([1, 3, np.nan, 12])) dat3 = pd.Series(['aa', 'bb', 'c', 'd']) dat4 = pd.Series([1, 'aa', 2.34, 'd']) 行ラベルを指定しなかった場合には自動的に0から始まる整数が割り振られる。行ラベルの設定には生成時に引数としてindexを指定するか、辞書型変数（またはリテラル）をシリーズに渡すことで表ラベルを指定する方法がある。\ndat5 = pd.Series([1, 3, 6, 12], index=[1, 10, 20, 33]) dat6 = pd.Series([1, 3, 5, 12], index=['a', 'b', 'c', 'a']) dat7 = pd.Series({'a':1, 'b':3, 'c':6, 'd':12}) 行ラベルはindexという属性で割り当てられているため、indexという変数で行ラベルを参照したり変更したりすることも可能である。\ndat8.index = ['un', 'due', 'trois', 'quatre'] print(dat8.index) また、シリーズ形式では辞書型と違いデータに順番があり、0からカウントアップする順序インデックスが割り当てられている。（c言語の配列の添字みたいなもの） そのためilocプロパティで順序インデックスを使用することでデータを取り出すこともできる。\ndat6.iloc[3] 2. DataFrame DataFrameは2次元のラベル付きデータ構造で、Pandasの中で最も使われることが多いデータタイプである。 Numpyからは2次元のndarrayをそのまま入力することができる。\nデータフレームでは行ラベル(index)と列ラベル(culmn)を同時に指定することができ、行ラベルはindex、列ラベルはculmnでそれぞれ参照/変更することができる。\n以下はDataFlameを格納する場合の一例である。\nfruit_dat = {'c_都道府県':['山梨', '福島', '長野', '栃木', '福岡', '熊本', '青森', '長野', '岩手'], 'a_果物':['モモ', 'モモ', 'モモ', 'りんご', 'りんご', 'りんご', 'いちご', 'いちご', 'いちご']} d = pd.DataFrame(fruit_dat)#辞書型からデータフレームに変換 d.columns print(Index('a_果物', 'b_収穫量順位', 'c_都道府県'], dtype='object')) ただしデータの列の順序は、列ラベルによって自動的にソートされて順序が変わるため注意が必要である。 上記の例でもデータを与えたときとデータフレームに格納後の順序は違っている。そこでデータフレームに格納する際に順序を変えないようにするには次のようにcolumns引数によって列の順序を指定することができる。\nd2 = pd.DataFrame(fruit_dat, columns = ['a_果物', 'c_都道府県', 'd_収穫量順位']) またシリーズを要素に持つ辞書型やリストからデータフレームを生成することも可能であり、データフレーム生成時に指定できるデータの方を次の表に示す。\nデータ型 概要説明 辞書型 辞書型の値としてリスト/タプル/シーケンスデータ/シリーズ/辞書型を値に持つもの リスト 辞書型、シリーズ、リストまたはタプルのリスト 別のデータフレーム データフレームの浅いコピーが生成される Numpyの2次元ndarrayもしくはMaskedArray データフレームの場合は2次元なので、2次元配列を受け付ける 階層化インデックスについて 3次元以上のデータを2次元データ形式のデータフレームで扱うためには行ラベルや列ラベルを複数階層のデータにする必要がある。 そのために必要なのが階層型インデックスである。\ndf = pd.DataFrame(np.random.rand(4, 4), index = [['x', 'x', 'y', 'y'], [0, 1, 0, 1]], columns = ['Time_a', 'Time_b', 'Vel_a', 'Vel_b']) a = df.xs(0, level=1, axis=0); a#データフレームのdxメソッドを使って、特定のラベル値のデータを抜き出す この例ではランダムに生成した4×4の行列データに対して2次元リストによる行ラベル(index)指定により、 xとyで区別される階層と0と1で区別される階層の2階層の行ラベルがつけられている。また2行目では表ラベルが(axis=0)の2層目(level=1)が0のデータを抽出している。\nあとから階層型インデックスに変換する場合には次のように列ラベルを_で分割して多階層化する。\ndf.columns = pd.MultiIndex.from_tuples([tuple(c.split('_')) for c in df.columns]) 3. Panel パネルは3次元データの格納用に用意されたデータ構造である。 データフレームよりも次元が1つ大きくなるためitemsという属性が1つ増えており、次のように生成することができる。\n## キーの準備（キー：アイテム名、値：データフレーム） data = {'Iyrm1': pd.DataFrame(np.random.randn(3, 2)), 'Item2' : pd.DataFrame(np.random.randn(3, 2))} pp1 = pd.Panel(data); pp1 ここではアイテム名としてItem1, Item2が指定されており、pp1.Item1などのように記述することでそのアイテム名に対応するデータフレームにアクセスすることができる。\nただしPanelではindexはmajor_axis, columnはminor_axisという属性で割り当てられているため 行ラベルと列ラベルを指定してパネルを生成する場合には注意が必要である。\npp2 = pd.Pane(np.random/randn(2, 4, 3), items=['Item1', 'Item2'], major_axis=pd.data_range('2/1/2016', periods=4), minor_axis=['one', 'two', 'three']) print(pp2.major_axis) print(pp2.Item1.index) ただし上記のプログラムの下2行は等価であり、同じ値を出力する。\nAPI(Spplicatopm Programming Interfave)とは？ APIとはデータ処理/解析向けに実装されている様々な機能にアクセスする窓口となっている関数や メソッドのことである。\nPandasの機能はPandas固有のデータ型ので意義が中心にあり、それにアクセスするための機能として、 pandasの関数とデータ型のメソッドの2種類のAPIがある。\n外部ライブラリでは、Numexprやbottleneck(ndarray用の高速関数実装), Cythonが高速化のために使用され、 MatplotlibやXlsxWriter(Excelへの書き込み機能を提供するライブラリ)などは拡張機能として利用できる。\nまた、Pandasの機能にはixやlocなどのプロパティも若干含まれている。これらは属性に直接アクセスしないで何らかの処理を経由して属性にアクセスする仕組みであり、インスタンスの属性を取り出したり設定したりするのに用いられる。\nプロパティを使用したデータフレームのインデックス参照 下記のようなインデックス参照では、値を参照することも、その参照ポイントに値を設定することも可能。\nプロパティ 概要 at 行ラベルと列ラベルによりスカラー値（1つのデータ）への参照を得る。locより高速 iat 行番号と列番号によりスカラー値（1つのデータ）への参照を得る。locより高速 loc 行ラベルと列ラベルによりベクトル（複数データ）またはスカラー値（1つのデータ）への参照を得る。 iloc 行番号と列番号によりベクトル（複数データ）またはスカラー値への参照を得る ix 通常はlocのように機能するが、ラベルが指定されていない場合はilocのように機能する。 参照方法 説明 df.at[‘y’, ‘b’] y行かつb列の値 df.loc[‘y’, ‘b’] y行かつb列の値 df.loc[‘x’:‘y’, ‘b’] 「「x行からy行(y行含む)」かつ「b列」の値 df.loc[:‘y’, :] 「最初の行からy行（y行含む）」かつ「b列」の値」 df.iat[0, 1] 0行1列の値 df.iloc[1, 1] 1行1列の値 df.iloc[0:2, -2:] 0〜１行かつ最後の２列の値 df.iloc[:1, :] 0行全列 df.ix[‘x’, [‘a’, ’d’]] 「x行」かつ「a列またはd列」 df.ix[‘x’] x行を取り出し（結果はシリーズ） df.ix[‘x’][‘a’] x行かつa列 df.ix[:, ‘a’] a列を取り出し（結果はシリーズ） df.ix[df.d \u003e 6, :2] 「d列が６より大の行」かつ「最初の２列」 同じデータを参照する方法は複数あるが、使っているOSやpandasの実装の改善等によって処理速度に差がある場合がある。そのような場合は%timeitマジックコマンドを使えば、簡単に調べることができる。\nデータフレームに対する直接インデックス参照 参照方法 説明 df[‘a’] 列ラベルaの列 df[[‘a’, ‘c’] 列ラベルaよc df[:2] ０行目と１行目 df[df[’d’] \u003e 6] 列ラベルdの列の値が６より大の行の行全体 基本的な演算規則 シリーズやデータフレームなどに対する四則演算は、加減乗除の記号によって実現する方法とメソッドを使う方法の２種類がある。\n加減乗除 要素ごとに演算を行う\nser_a1 = ser1 + ser2 メソッド インスタンスデータが変更されるものではないため、何らかの変数に格納する必要がある。\nser_a2 = ser1.add(ser2) NaNを含む式の計算はすべてNaNとなるが、メソッドを使用した計算ではNaNを特定の 値に置き換えて計算できるという利点がある。\nPandasの使い方 DataFlame DataFlameの定義 pd.DataFrame({'Yes': [50, 21], 'No': [131, 2]}) Yes No 0 50 131 1 21 2 pd.DataFrame({'Bob': ['I liked it.', 'It was awful.'], 'Sue': ['Pretty good.', 'Bland.']}) fruits = pd.DataFrame([[30, 21]], columns=['Apples', 'Bananas']) index化 fruit_sales = pd.DataFrame([[35, 21], [41, 34]], columns=['Apples', 'Bananas'],index=['2017 Sales', '2018 Sales']) Series Seriesの定義 pd.Series([1, 2, 3, 4, 5]) index化 pd.Series([30, 35, 40], index=['2015 Sales', '2016 Sales', '2017 Sales'], name='Product A') quantities = ['4 cups', '1 cup', '2 large', '1 can'] items = ['Flour', 'Milk', 'Eggs', 'Spam'] recipe = pd.Series(quantities, index=items, name='Dinner') csvファイルへの入出力 animals.to_csv(\"cows_and_goats.csv\") reviews = pd.read_csv('../input/wine-reviews/winemag-data_first150k.csv', index_col=0) ※index_col=0で0列目をindexに指定している。\nUnicodeDecodeError: ‘utf-8’ codec can’t decode byte 0x92 in position 0: invalid start byte というエラーが出る 【解決法】\n**shift-jisの場合\nimport pandas as pd df = pd.read_csv(\"filename.csv\", encoding=\"shift-jis\") windowsで作成されたファイルは以下の場合も\nimport pandas as pd df = pd.read_csv(\"filename.csv\", encoding=\"cp932\") 【参考】エラー解決：pandas.read_csvで日本語を含んだcsvを読み込めない\nPandasでのindexing indexによるデータへのアクセス attribute や operator [] によるアクセス\nreviewsデータが次のような値を持つとすると、\n| --- |country|description|designation| | --- | --- | --- | --- | |0| Italy| Aromas include tropical fruit, broom, brimston... |Vulkà Bianco | |1| Portugal| This is ripe and fruity, a wine that is smooth...| Avidagos | |...| ...| ... |...| |129969| France| A dry style of Pinot Gris, this is crisp with ... |NaN | |129970| France| Big, rich and off-dry, this is powered by inte... |Lieu-dit Harth Cuvée Caroline | reviewsのcountryプロパティへは以下のいずれかの方法でアクセスする\nreviews.country reviews['country'] ※ただし[ ]であれば+, -, 空白 などの予約文字も扱え、以下のようにもう一度[]を使うだけでドリルダウンできる（下記の出力はItaly）\nreviews['country'][0] locやilocによるアクセス\n例文 desc = reviews.description or desc = reviews[\"description\"] desc is a pandas Series object, with an index matching the reviews DataFrame. In general, when we select a single column from a DataFrame, we'll get a Series. Solution: first_description = reviews.description.iloc[0] Note that while this is the preferred way to obtain the entry in the DataFrame, many other options will return a valid result, such as reviews.description.loc[0], reviews.description[0], and more! first_row = reviews.iloc[0] first_descriptions = reviews.description.iloc[:10] Note that many other options will return a valid result, such as desc.head(10) and reviews.loc[:9, \"description\"]. indices = [1, 2, 3, 5, 8] sample_reviews = reviews.loc[indices] cols = ['country', 'province', 'region_1', 'region_2'] indices = [0, 1, 10, 100] df = reviews.loc[indices, cols] cols = ['country', 'variety'] df = reviews.loc[:99, cols] or cols_idx = [0, 11] df = reviews.iloc[:100, cols_idx] italian_wines = reviews[reviews.country == 'Italy'] top_oceania_wines = reviews.loc[ (reviews.country.isin(['Australia', 'New Zealand'])) \u0026 (reviews.points \u003e= 95) ] Pandas 「Summary Functions and Maps」 Numpyで要約統計量の取得\nmedian_points = reviews.points.median() countries = reviews.country.unique() reviews_per_country = reviews.country.value_counts() centered_price = reviews.price - reviews.price.mean() bargain_idx = (reviews.points / reviews.price).idxmax() bargain_wine = reviews.loc[bargain_idx, 'title'] n_trop = reviews.description.map(lambda desc: \"tropical\" in desc).sum() n_fruity = reviews.description.map(lambda desc: \"fruity\" in desc).sum() descriptor_counts = pd.Series([n_trop, n_fruity], index=['tropical', 'fruity']) def stars(row): if row.country == 'Canada': return 3 elif row.points \u003e= 95: return 3 elif row.points \u003e= 85: return 2 else: return 1 star_ratings = reviews.apply(stars, axis='columns') Groutping and Sorting Groupwise amalysis 次のようなgroupby()関数を用いることで指定した列の同じ値を持つデータをグループ化し、 同じ操作を行うことができる。\npoint列の同じ値を持つものをグループ化し、その値が何回出現したかをカウントする。出力はpointの値と出現回数の 以下どちらの方法でもOK！ reviews.groupby('points').points.count() pointの値の小さい順で出力 【出力結果】\npoints 80 397 81 692 ... 99 33 100 19 Name: points, Length: 21, dtype: int64 reviews.value_counts('points') 出現回数の大きい順で出力\npoint列の同じ値を持つものをグループ化し、そのprice列の最小値を配列Seriesに格納\nreviews.groupby('points').price.min() 【出力結果】\npoints 80 5.0 81 5.0 ... 99 44.0 100 80.0 Name: price, Length: 21, dtype: float64 title列に同じ値を持つものをグループ化し、そのグループ内で最も行数が少ない要素のtitle列の値を出力\nreviews.groupby('winery').apply(lambda df: df.title.iloc[0]) その他 reviews_written = reviews.groupby('taster_twitter_handle').size() reviews_written = reviews.groupby('taster_twitter_handle').taster_twitter_handle.count() best_rating_per_price = reviews.groupby('price')['points'].max().sort_index() price_extremes = reviews.groupby('variety').price.agg([min, max]) sorted_varieties = price_extremes.sort_values(by=['min', 'max'], ascending=False) reviewer_mean_ratings = reviews.groupby('taster_name').points.mean() country_variety_counts = reviews.value_counts(['country', 'variety']) または\ncountry_variety_counts = reviews.groupby(['country', 'variety']).variety.count().sort_values(ascending=False) ※count()モジュールはsize()モジュールでもOK!\n参考文献 https://qiita.com/propella/items/a9a32b878c77222630ae https://note.nkmk.me/python-pandas-map-applymap-apply/ https://ejje.weblio.jp/content/fit https://note.nkmk.me/python-pandas-at-iat-loc-iloc/ Data Types and Missing Values dtype = reviews.points.dtype point_strings = reviews.points.astype(str) missing_price_reviews = reviews[reviews.price.isnull()] n_missing_prices = len(missing_price_reviews) または\n## Cute alternative solution: if we sum a boolean series, True is treated as 1 and False as 0 n_missing_prices = reviews.price.isnull().sum() または\n## or equivalently: n_missing_prices = pd.isnull(reviews.price).sum() reviews_per_region = reviews.fillna(\"unknown\").groupby('region_1').region_1.count().sort_values(ascending=False) または\nreviews_per_region = reviews.region_1.fillna('Unknown').value_counts().sort_values(ascending=False) Renaming and Combining renamed = reviews.rename(columns={'region_1':'region', 'region_2':'locale'}) または\nrenamed = reviews.rename(columns=dict(region_1='region', region_2='locale')) reindexed = reviews.rename_axis('wines', axis='rows') combined_products = pd.concat([gaming_products, movie_products]) powerlifting_combined = powerlifting_meets.set_index('MeetID').join(powerlifting_competitors.set_index('MeetID')) または\npowerlifting_combined = powerlifting_meets.set_index(\"MeetID\").join(powerlifting_competitors.set_index(\"MeetID\")) Pandasの便利なfunction “shape” attribute wine_reviews.shape 【出力】\n(129971, 14) DataFrameがどれくらいの大きさを持つかを出力する関数 14の異なる列に分割された130,000のレコードを持つ 約2,000万個のエントリを持つ “head()” command wine_reviews.head() 先頭から5行を表示するコマンド 差分を計算 df_re = df.diff() 【出力結果】\na b c 0 NaN NaN NaN 1 1.0 3.0 7.0 2 1.0 5.0 19.0 3 1.0 7.0 37.0 4 1.0 9.0 61.0 【引数】\nパラメータ 概要 periods 指定した行数分だけ前（もしくは後）の要素との差を求める ※負の値も指定可能（付の値では後ろの要素がNaNの値をとる） axis axis=1と指定すると列ごとの差分を算出（デフォルトは0） 【参考】\npandasで行・列の差分・変化率を取得するdiff, pct_change index の割当 indexの初期化\ndf_i = df.reset_index() ※ノーマルではindexの値が新しい列として挿入される ※（）内に’drop=False’と記述するとデータ部はそのままでindexだけ変更できる\nDataFrameの列をindexに指定\ndf_i = df.set_index('name') ※ name という列を index として指定\n【引数】\n引数 コマンド 概要 drop drop = False 指定列がデータ列にも残るデフォルトではindexに指定されたデータ列は消える(drop = True) 【参考】\npandas.DataFrame, Seriesのインデックスを振り直すreset_index pandas.DataFrameの列をインデックス（行名）に割り当てるset_index カラム名の変更 arra.columns = ['A', 'B'] 【参考】\npandas.DataFrameの行名・列名の変更 DataFrameやSeriesの文字列や空白を削除 概要 コマンド 文字列の置換 .str.replace('置換前', '置換後') 空白の削除(左右) .str.strip() 空白の削除（左） .str.lstrip() 空白の削除(右) .str.rstrip() 型変換と型判定 概要 コマンド if文で型を判定(出力はTrue or false if type(a) == int: str型とfloatまたはint型の変換 .astype(変更後の型名(int or float or str)) ※strからintへは直接変換できないため一度float型に変換する 各要素ごとに型の確認（配列として出力される） .dtype() 【参考】\nPythonでtype関数を利用して型判定する方法を現役エンジニアが解説【初心者向け】 DataFrame または Series で特定の文字列を検索 概要 コマンド 完全一致(==) 要素が文字列に完全一致するとTrueとなるpandas.Seriesを取得できる。 変数名[変数名['列名'] == '検索する文字列'] 【参考】\npandasで特定の文字列を含む行を抽出（完全一致、部分一致） Series や DataFrame の結合 concat 関数 下記のように記述することで DataFrame s1 とs2 が結合できる(結合したDataFrameが返却値)\narr = pd.concat([s1, s2]) 【引数】\n引数 引数の指定方法 概要 axis axis=0 縦方向に（行で）連結 axis axis=1 横方向（列で）連結 join よくわかってない… →　後で調べて 内部結合・外部結合を指定 merge 関数 また調べて… 【参考】\npandas.DataFrame, Seriesを連結するconcat pandasの使い方（merge、join、concat編） pandasで要素・行・列荷関数を適用 対象 関数 概要 Series map Series の各要素に関数を適用 Series, DataFrame apply Series の各要素に関数を適用（デフォルトはaxis=0で各列に対する処理、axis=0で各行に対する処理も可能） DataFrame applymap DataFrameの各要素に関数を適用 fx = lambda x: x * 2 / a 【参考】\npandasで要素、行、列に関数を適用するmap, applymap, apply pandas.DataFrameの行や列を削除 pandas.DataFrameの行・列を指定して削除するdrop 【参考】\npandasの文字列メソッドで置換や空白削除などの処理を行う 【参考】\npandasの文字列メソッドで置換や空白削除などの処理を行う pandasで文字列と数値を相互変換、書式変更 pandasで特定の文字列を含む行を抽出（完全一致、部分一致） Pythonでtype関数を利用して型判定する方法を現役エンジニアが解説【初心者向け】 pandasの使い方（merge、join、concat編） pandas.DataFrame, Seriesを連結するconcat pandas.DataFrameの列をインデックス（行名）に割り当てるset_index pandas.DataFrame, Seriesのインデックスを振り直すreset_index pandas.DataFrameの行名・列名の変更 pandasで要素、行、列に関数を適用するmap, applymap, apply pandasで行・列の差分・変化率を取得するdiff, pct_change pandas.DataFrameに列や行を追加（assign, appendなど） ",
    "description": "",
    "tags": null,
    "title": "Pandas",
    "uri": "/watanuki/python/pandas/index.html"
  },
  {
    "content": "Pythonが動的に解釈を行う言語であるという性質上、for文などのループを繰り返す場合には低速性が特に顕著に現れる。したがって一般的にPythonではfor文を多様せず、numpyやPandas等の高速なライブラリを利用する。\nNumpyは多くの操作に対して静的型付きでコンパイルされた関数への便利なインターフェースを提供している。 これはベクトル化操作として知られており、配列に対して操作を実行するだけで、各要素に適用される。\nNumpyのベクトル化演算は、ufunc(ユニバーサル関数)を使用して実装されており、このufuncの主な目的は、Numpyの各要素に対して繰り返し演算を素早くすることにある。\n便利なNumpy関数 以下ではimport numpy as npとしてnumpyをimportしているものとする\nnpはnumpy, shapeは配列の形状, arrは任意の配列を示す\nNumpyで実装されている演算子とその等価なufunc\n関数 等価なufunc 説明 + np.add(arr, x) 加算(arrやxの順序はとわない。また配列同士、変数同士でも演算可) - np.subtract(arr, x) 減算（以下同文） - np.negative(arr) 単行マイナス * np.multiply(以下略) 乗算 / np.divide 除算 // np.floor_divide 整数除算(小数点以下切り捨て) ** np.power べき乗 % np.mod 剰余 Numpyで実装されている比較演算子とその等価なufunc\n演算子 等価なufunc == np.equal != np.not_equal \u003c np.less \u003c= np.less_equal \u003e np.greater \u003e= np.greater_equal Numpyのufunc\n関数 説明 引数 arr.reshape(shape) 配列arrを指定したshapeの型に変形 shape arr[np.axis] 新しく次元を追加 — np.concatenate([arr1, arr2, arr3]) 次元の同じ複数の配列を結合 連結する配列(タプルまたは配列のリスト), axis=0で第1の軸方向に結合（デフォルト）, axis=1で第2の軸方向 np.vstack([arr1, arr2]) 混合次元の配列を垂直に重ねる 連結する配列 np.hstack([arr1, arr2]) 混合次元の配列を水平に重ねる 連結する配列 np.split([arr], [a,b]) 配列を分割 分割する配列, [a,b]は分割点を与えるインデクスのリスト np.vsplit([arr], [a]) 配列の垂直方向の成分を分割 分割する配列, [a]は分割点を与えるインデクスのリスト np.hsplit([arr], [a]) 配列の水平方向の成分を分割 分割する配列, [a]は分割点を与えるインデクスのリスト np.dsplit([arr], [a]) 配列を第3軸に沿って分割 分割する配列, [a]は分割点を与えるインデクスのリスト np.absolute(arr) または np.abs(arr) 絶対値を返却（複素数データも扱える） np.sin(arr) sin関数の計算結果を返却(cos, tanも同様) np.arcsin(arr) arcsin関数の計算結果を返却(cos, tanも同様) np.exp(arr) 指数関数の計算結果を返却 np.power(x, arr) x^arrの値を返却 np.log(x) ln(x)の値を返却 np.log2(x) log2(x)の値を返却 np.expm1(x) exp(x)-1 の値を返却(xの値が非常に小さいときにnp.exp よりも良い制度で計算する) np.log1p(x) log(1+x) の値を返却(xの値が非常に小さいときにnp.log よりも良い制度で計算する) numpyの集約関数\n関数名 NaNセーフ版 説明 np.sum np.nansum 要素の合計を計算する np.prod np.nanprod 要素の積を計算する np.mean np.nanmean 要素の平均値を計算する np.std np.nanstd 要素の標準偏差を計算する np.var np.nanvar 要素の分散を計算する np.min np.nanmin 最小値を見つける np.max np.nanmax 最大値を見つける np.argmin np.nanargmin 最小値のインデクスを返す np.argmax np.nanargmax 最大値のインデクスを返す np.median np.nanmedian 要素の中央値を計算する np.percentile np.nanpercentile パーセンタイルを計算する np.any N/A いずれかの要素がtrueであるかを評価する np.all N/A すべての要素がtrueであるかを評価する ※arr.sum()のように配列に.をつけることで計算もできる\nufuncの特殊な機能\n概要 書き方 説明 書き込み np.power(2, arr, out=arr2) powerの出力結果をout=で指定した配列arr2に直接書き込む。arr2 = np.power(2, arr)と等価だが、一時的な配列を作成しなくてすむため、非常に大きな配列などの場合にはメモリの節約につながる reduceメソッド np.multiply.reduce(x) 任意のnumpy関数に対して.reduce(x)のようにすることで要素が1つになるまで演算を行う。ここではすべての要素の積を計算している。 accumelateメソッド np.multiply.accumelate(x) reduceの中間バージョン) outerメソッド np.multiply.outer(x, x) 2つの入力のすべての要素間で任意の計算が行える。ここではすべての要素間での積（外積）を求めている。 ※異なるサイズと形状の配列間で操作を可能とするブロードキャスト機能と呼ばれるものもある\n※その他にもscipy.specialでガンマ関数や誤差関数などが実装されていたりもするので難しい計算などは検索してみること！\nブロードキャスト ブロードキャストとは異なるサイズの配列に対して二項ufunc（加算、減算、乗算など）を適用するための一連のルールである。\n1. ブロードキャストの基礎 同じサイズの配列に対しての二項演算は要素ごとに実行される\nブロードキャストでは次のルールに従って行われる\n２つの配列の次元数が異なる場合、次元数の少ない方の形状は、先頭の（左側）に１を補い次元数を揃える。\n２つの配列の形状がいずれの次元でも一致しない場合、各次元のうち長さが１に等しい次元は、他方の配列形状と一致するように引き伸ばされる。\nいずれかの次元でサイズが不一致で、長さが１に等しくもない場合は、エラーとなる、。\n",
    "description": "",
    "tags": null,
    "title": "Useful Functions in Numpy",
    "uri": "/watanuki/python/numpy_function/index.html"
  },
  {
    "content": "1. Numpy　概要 Pythonにはデータの集合を扱うための様々なデータ型がある。\n標準で用意されているもの 名前 例 リスト(list) L=[\"kiwi\", \"banana\", \"apple\"] インデックス番号付き集合 タプル(tuple) T=(\"kiwi\", \"banana\", \"apple\") インデックス番号付き集合(代入不可) 辞書(dict) D={\"kiwi\":3, \"banana\":2, \"apple\":3} インデックス番号無し (key,value) 対応表 集合(set) S={\"kiwi\", \"banana\", \"apple\"} インデックス番号無し集合 拡張モジュールを利用するもの。 名前 例 numpy.ndarray N=np.array([1,2,3]) 数値計算用の多次元配列（ブロードキャストを提供する高速で目盛り効率の良い多次元配列が実装されている。 ） pandas.Series s=pd.Series([280,198],index=['tomato','banana']) 行に名前がある1次元配列 pandas.DataFrame df=pd.DataFrame([['tomato',280],['banana', 198]], columns=['name','price']) 列や行に名前がある2次元配列 Numpyとは？ NumpyとはN次元配列(N-dimensional array, ndarray)を定義し、ベクトルや行列をはじめとする数値計算を行うためのモジュールであり、以下のような特徴を持つ。\nC言語で記述されているため高速処理可能 高速に動作し、呼び出しにループ記法を必要としない標準的な数学関数 Numpyモジュールで生成する配列の型名はnumpy.ndarray ディスクへの読み書きに加え、メモリマップファイル機能を提供する入出力 行列計算、乱数生成、フーリエ変換の各機能 C, C++, Fortran へのインタフェース(C言語呼び出しのAPIがあることで、NumpyからC言語で書かれた外部ライブラリへデータを渡したり、逆に外部ライブラリの計算結果をNumpyに戻し、ndarrayとして扱うこともできる。) ※Numpyはデータ演算の基盤を提供するが、実際に構造化データや表形式データを分析する場面ではpandasを用いるのが一般的\nモジュールの読み込み NumPyモジュールは慣例的にnpの名称で利用される。\nimport numpy as np print(np.__version__) Numpyのマニュアル参照 np? Numpyの関数とメソッド 配列ndarrayの生成や，複数の配列に対する操作(結合等)には, NumPyの関数を使う すで生成されているndarrayオブジェクトの加工には，ndarrayに対するメソッドを使う ※　以下では，NumPyの関数とメソッドの説明の際に，両者を以下のように書いて区別する\n関数: numpy.array()のように，モジュール名numpyもしくは略称npをつけて説明 メソッド: ndarray.reshape()のように、ndarrayをつけて説明（ndarrayの部分には配列名が入る） 2. 配列ndarrayの生成 生成関数一覧 関数 説明 array リスト、タプル、Python配列、その他列挙型といったデータを受取り、ndarrayを生成（要素の型は推測されてもの、あるいは明示的に指定されたもの） asarray array同様ndarrayを生成。ただし入力がndarrayの場合には新規に変数を生成しない arange Python組み込み関数のrange関数と同じ動作でndarrayを生成 ones, ones_like 指定された形状の配列で要素をすべて 1 で埋めたndarrayを生成 zeros, zeros_like ones, ones_like同様にndarrayを生成。要素はすべて 0 で埋められる empty, empty_like 以下同文。要素は初期化されておらず不定 eye, identity N ✕ N の単位行列となるndarrayを生成 ndarray に関する情報の取得 コマンド 説明 x.dtype 値のデータ型(int, float など) x.ndim 次元 x.shape 形状(1次元なら要素数、2次元なら行と列数etc.) x.size 要素数 x.itemsize 要素のメモリサイズ [byte] len(x) 1次元配列に対しては要素数と同じ 関数 関数 説明 astype 引数には\"型名\"を指定(ndarrayの配列に対して arr.dtype などでもOK) 2.1 リストやタプルからndarrayへの変換 リスト(list)のndarrayへの変換\nx = np.array([1, 2, 3]) print(x) 【出力】 [1 2 3] l = [1, 3, 5] y = np.array(l, dtype='float') print(y) 【出力】 [1 3 5] ※dtype=で変数の型を明示的に指定 np.array([[0, 1], [2, 3]]) 【出力】 array([[0, 1], [2, 3]]) タプル(tuple)からndarrayへの変換\nt = (2, 4, 6) z = np.array(t) print(z) 【出力】 [2 4 6] 2.2 関数を用いた配列ndarrayの生成 同じ要素値をもつndarrayの生成 ※以下でのshapeには配列の形状を記述する（配列の形状については後述）\n要素の初期値なし(適当な値が入っているおそれあり)\nnumpy.empty(shape) 要素値は0に初期化\nnumpy.zeros(shape) 要素値は0に初期化し、形状(shape)が配列aと同じになる\nnumpy.zeros_like(a) 要素値は1に初期化\nnumpy.ones(shape) 要素値は1に初期化し、形状(shape)が配列aと同じになる\nnumpy.ones_like(a) 要素値はvalに初期化\nnumpy.full(shape, val) 要素値はvalに初期化し、形状(shape)が配列aと同じになる\nnumpy.full_like(a, val) （例）\nprint(np.ones(10, dtype=int)) #値が1となる10個の要素を持つint型の配列 print(np.full(5, np.pi)) #値がπ(np.pi)となる5個の要素を持つ配列 ※上記のように要素の型を指定することも可能(要素の型の指定については以下で後述)\n等差数列の生成 区間と間隔(step)を指定する方法 np.arange(end) #[0, end)の区間の整数値を生成 np.arange(start, end) #[start, end)の区間の整数値を生成 np.arange(start, end, step) #[start, end)の区間内でstep幅ごとの整数値を生成 区間と分割数を指定する方法 numpy.linspace(start, end, num) #[start, stop]の区間を端点を含むnum個の境界値で分割し、その境界値を返す ※numは端点を含むので、num = 分割したい個数＋1になることに注意 単位行列の生成 numpy.identity(n) #n×nの単位行列の生成 numpy.eye(n, m=n) #n×mの単位行列の生成 ※mは省略可能。省略した場合は正方行列になる\n乱数による配列の生成 一様乱数による配列の生成\nnumpy.random.rand(dim0, dim1, …)\nnumpy.random.rand(dim0, dim1, ...) #要素値が0から1の一様乱数であり、shapeが(d0, d1, ...)となるndarrayの生成 (例)　要素値が0から1の一様乱数である、2×3の二次元配列の生成\nnp.random.rand(2, 3) ``` numpy.random.randint(low, high, size)\nnumpy.random.randint(low, high, size) #[low, high)の区間における整数乱数を要素値とし、shapeがsizeのndarrayを生成 (例)　0以上5以下の整数乱数を要素とする2×2×2の3次元配列の生成\nx = np.random.randint(0, 6, (2, 2, 2)) y = np.random.randint(6, size=(2, 2, 2)) ``` 正規分布に従う乱数の生成\nnp.random.normal(loc, scale, size) #平均がloc, 標準偏差scaleのガウス分布に従う乱数を要素とする、 #shapeがsizeのndarrayを生成 numpy.random.randn(d0, d1, d2, ...) #平均0, 標準偏差1のガウス分布に従う乱数を要素とする、 #shapeが(d0, d1, d2, ...)のndarrayを生成 3. ndarrayの要素の型 要素の型の確認 リスト(list)では要素にいろいろな型を混在させることができるが、Numpyの配列では各要素が同じ型である必要がある。\nndarrayの要素のデータ型は次のように確認できる。\nx = np.array([1, 2, 3]) print(x.dtype) Numpyオブジェクトの要素の方は次のように陽に（明示的に）指定することもできる。\nx = np.array([1, 2.1, 3], dtype=np.int) #x = np.array([1, 2.1, 3], dtype=\"int\") # 上と同じ意味 ※関数を用いて配列を生成するときも使用できる！\n要素の型を混在させて定義させた場合、どちらかの型で定義される\nintとfloatではすべてfloatに変換して定義される。 4. 配列ndarrayの次元、形状、要素数 配列ndarrayの次元、形状、要素数は属性ndim, shape, sizeに定義されている。\n次のようにndim, shape, sizeにアクセスすることで次元、形状、要素数の情報を取得することができる。\nx = np.array([[0, 1], [2, 3], [4, 5]]) print(x) print(x.ndim) #次元 print(x.shape) #形状(1次元なら要素数、2次元なら行と列数etc.) print(x.size) #要素数 print(x.itemsize) #各要素のメモリサイズ [byte] print(x.nbytes) # 配列の合計サイズ [byte] print(len(x)) #1次元配列に対しては要素数と同じ 【出力結果】\n[[0 1] [2 3] [4 5]] ndim: 2 shape: (3, 2) size: 6 itemsize: 8 length: 3 5. 配列の参照 5.1 1次元配列の参照 ndarrayの要素値を参照する方法はリスト(list)と同様に行うことができる。 つまりインデックスに[begin:end:step]と記述し範囲を指定することで参照できる。\n(例)次のように定義したリストxについての参照\nx = np.arange(1, 10) xの要素一覧\nprint(x) 一番はじめの要素\nx[0] 最後から２番めの要素\nx[-2] はじめの３つの要素\nx[:3] 最後の３つの要素\nx[-3:] はじめの要素から、一つおきに要素値を表示\nx[::2] 要素を逆順に表示(インデックス指定のステップ値に負の値を使う)\nx[::-1] 5.2 2次元配列の参照 ndarrayの2次元配列では、行および列それぞれに対する範囲を[行に対する範囲, 列に対する範囲]と指定することで参照・スライスできる。\n※スライス構文では[start:stop:step]のように指定する（stepは省略可）\n(例)次のように定義した2次元配列の参照\nN = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) print(N) [[ 1 2 3 4] [ 5 6 7 8] [ 9 10 11 12]] はじめの行のみ\nprint(N[0, :]) print(N[0]) 最後の列のみ\nN[;, -1] はじめの2行かつ、はじめの3列以内の要素\nN[:2, :3] 奇数番目の列とすべての行要素でできる行列\nN[:, ::2] Nの右下部分の要素でできる2行2列の部分行列（インデックスに負の値を使う）\nN[-2:, -2:] 行を逆順にした（列順は変えない）行列\nN[::-1,] 6 配列ndarrayのコピー 配列ndarrayのコピーにはshallow copy と Deep copyの2通りがある\nShallow Copy : 浅いコピー\npythonではオブジェクトの生成時に固有のidがふられる。(C言語で言うポインタとはまた別のもの、ポインタの役割をするものは別に存在する？) Shallow Copyではオブジェクトのidのみをコピーする。 同じidを参照するための別名をつくることになる。 次のような変数へのndarrayの代入もリストオブジェクトと同様にShallow Copyとなる。 p = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) q = p Deep Copy : 深いコピー\n新たなオブジェクトを生成し，そこに参照元の値をコピーすること。 ndarrayの Deep Copy には，次のようにcopy()メソッドを使う。 p = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) q = p.copy() Shalow Copyでは値のコピーは行わず、値を参照するためのid情報のコピーのみを行うので、ほとんどの場合Deep Copyより高速であり、メモリ消費も少ない。 7. 配列ndarrayの変形 shapeの変更の仕方 メソッド 概要 補足 ndarray.reshape(new_shape) 1次元配列を多次元配列に変形 new_shape：shapeを整数かtupleで指定 ndarray.ravel() 多次元配列を1次元配列に変形(Shallow Copy) — ndarray.flatten() 多次元配列を1次元配列に変形(Deep Copy) — ※ndarray.reshape()メソッドとndarray.revel()メソッドは要素値をShallow copyし、配列の見かけ(shape)のみが異なるオブジェクトを生成する。\nndarray.reshape()メソッドによるshapeの変更 要素数9の1次元配列を3×3の2次元配列に変形する例\nx = np.arange(9) print(x) x = x.reshape((3, 3)) print(x) 【出力】\n[0 1 2 3 4 5 6 7 8] [[0 1 2] [3 4 5] [6 7 8]] 配列のshapeに-1を指定する例 ※-1を指定することで自動でサイズを決めてくれる\nx = np.arange(9) print(x) x = x.reshape((3, -1)) print(x) 【出力】\n[0 1 2 3 4 5 6 7 8] [[0 1 2] [3 4 5] [6 7 8]] NumPyの関数numpy.arange()で生成したndarrayをメソッドndarray.reshape()で変形する例\nnp.arange(9).reshape((3, 3)) array([[0, 1, 2], [3, 4, 5], [6, 7, 8]]) 1から9の整数値を要素とする縦ベクトルの定義（以下2つの方法のどちらでも同様の出力を得られる）\nx = np.arange(1, 9).reshape((8, 1)) x = np.arange(1, 9) x = x[:, np.newaxis] # `np.newaxis`で新たな次元を追加(1次元なら2次元に、2次元なら3次元に) print(x) 【出力】 [[1] [2] [3] [4] [5] [6] [7] [8]] 8. 配列ndarrayの要素の追加 配列xに対して配列yを追加した配列は次のように得られる。 ```python x = np.array([1, 2, 3]) y = np.array([8, 9]) x = np.append(x, y) print(x) ``` 【出力】 ``` [1 2 3 8 9] ``` 2次元配列における配列の要素の追加 行数は変化させず、列数を増やす方向にqを結合する場合\nnp.append(p,q) または\nL = np.append(p, q, axis=1) 列数は変化させず、行数を増やす方向にqを結合する場合\nL = np.append(p, q, axis=0) 参考資料 PythonDataScienceHandbook Numpy numpy.random.rand(dim0, dim1, …) numpy.random.randint(low, high, size) shallow copy と Deep copy ",
    "description": "",
    "tags": null,
    "title": "Numpy",
    "uri": "/watanuki/python/numpy/index.html"
  },
  {
    "content": "Matplotlibとは？ グラフやそれ以外の2次元の形式で行うデータの可視化に用いるライブラリ。\n出版に適したグラフを作るのに非常に適しており、IPythonとうまく統合されているためIPythonとmatplotlibはデータのグラフ化や探索を容易に行えるインタラクティブな環境を提供している。 ウィンドウに表示されているツールバーからプロットの特定の領域をズームしたり、プロットで表示されれる範囲を変更することができる。\nMatplotlibにおけるグラフを書く方法 pypplot インターフェース\n単純なグラフの描画には便利 オズジェクト指向インターフェース\nサブグラフを用意するなど細かい指定をするときに便利 Pyplotインターフェース plt.から始まる命令で簡単にグラフをかける 単純なグラフ作成向け Numpyモジュールの使用 数学関数の描画には、ベクトル・行列演算用のNumPyモジュールを使うと便利。Numpyはリストと似ているが数値データの処理に特化したメソッドが色々用意されている。\n(例)\nimport numpy as np step=0.1 time=np.arange(0,20+step,step) # 0以上20+step未満の数値をstep刻みで生成 sint=np.sin(time) # timeの各要素に対するsin関数の値をリスト化 cost=np.cos(time) # timeの各要素に対するsin関数の値をリスト化 plt.figure(figsize=(8, 4)) plt.plot(time, sint, label=\"sin t\") # x,y軸データから，labelは省略可 plt.plot(time, cost, label=\"cos t\") # pltにcos関数のグラフも追加 # ラベル等の追加 plt.xlabel(\"time [s]\") # pltにx軸ラベル追加 plt.ylabel(\"y\") # pltにy軸ラベル追加 plt.legend(loc=\"upper right\") # pltに凡例(plot()の引数に指定したlabel)を追加 # plt.savefig('figure.png') # グラフを保存したい場合。拡張子に応じてpng,jpg,pdf等の出力可能 plt.show() # グラフオブジェクトpltの描画 オブジェクト指向インターフェース グラフの見栄え等に関する細かい設定をすることができる。 コンテナと呼ばれるオブジェクトの中に、描画パーツやさらにコンテナを配置していくことでグラフを作成する。 matplotlibのオブジェクト指向インターフェースの基本構造 matplotlibのオブジェクト指向インタフェースでは，以下のように階層的にコンテナや基本パーツを配置する。\nFigure (図)コンテナ 全ての描画オブジェクトに対して，一番上の階層にあるクラス。 複数のグラフ等(Axesオブジェクト等)を配置するキャンバス的な役割のオブジェクト Axes (座標系)コンテナ 個々のグラフ等に対応するオブジェクト 以下の座標軸(Axis)や描画グラフ(Primitives)を要素として登録する Axis (座標軸)コンテナ 個々の座標軸を表現するオブジェクト ラベルや目盛りなどを要素とする Primitives (基本パーツ) 直線オブジェクト(Line2D), テキストオブジェクト(Text)など各グラフに描画するオブジェクト コンテナの中に配置する (例)\n# time, sint, costの部分は前述のNumpyを使った方法と同じなので省略(すでに実行済みの場合，再度定義の必要なし) step = 0.1 time = np.arange(0, 20 + step, step) # 0以上20+step未満の数値をstep刻みで生成 sint = np.sin(time) # timeの各要素に対するsin関数の値をリスト化 cost = np.cos(time) # timeの各要素に対するsin関数の値をリスト化 plt.rcParams[\"font.size\"] = 16 # グラフのタイトルなどのフォントの大きさをまとめて16pointに fig = plt.figure(figsize=(6, 5)) # Figureオブジェクトfigを生成(横:縦=6:5) ax1 = fig.add_subplot(211) # figの中に座標(Axes)オブジェクト生成。2行1列に配置した1番目とする ax2 = fig.add_subplot(212) # 2行1列に配置した2番目のAxes生成 ax1.plot(time, sint, label=\"sin t\") # ax1にsin関数の折れ線グラフ(Primitives)登録(labelは省略可) ax2.plot(time, cost, label=\"cos t\") # ax2にはcos関数 # ax1にラベル等の追加 ax1.legend(loc=\"upper right\") # plot()で指定したlabelを右上に配置 ax1.set_title(\"graph example\") # タイトル ax1.set_xlabel(\"t [s]\") # x軸ラベル ax1.set_ylabel(\"sin t\") # y軸ラベル ax1.grid(True) # 格子を描く ax1.set_xlim(0, 20) # 描画範囲は[0, 20] ax1.set_ylim(-1, 1) # 描画範囲は[-1, 1] # ax2にラベル等の追加 ax2.legend(loc=\"upper right\") # plot()で指定したlabelを右上に配置 ax2.set_xlabel(\"t [s]\") # x軸ラベル ax2.set_ylabel(\"cos t\") # y軸ラベル ax2.grid(True) # 格子を描く ax2.set_xlim(0, 20) # 描画範囲は[0, 20] ax2.set_ylim(-1, 1) # 描画範囲は[-1, 1] plt.tight_layout() # タイトルやラベルが重ならないように配置調整し、Figureオブジェクトを描画 # plt.savefig('triangular.png') # グラフを保存したい場合。拡張子に応じてpng,jpg,pdf等の出力可能 plt.show() # 以上の命令を出力(画面表示)。Jupyter Notebookの場合は省略可能 ヒートマップ 3次元グラフのz軸の値を、2次元グラフ上の色や濃淡で表したグラフをヒートマップと呼ぶ。\n（例）\n%matplotlib inline import numpy as np from matplotlib import pyplot as plt # ここまでは，すでに実行ずみなら不要 data = [[1,2,3,4], [2,3,4,5], [3,4,5,6], [4,5,6,7]] fig=plt.figure(figsize=(6, 5)) # グラフを生成 ax=fig.subplots() # 座標コンテナを1つ生成してaxに代入 # ax.invert_yaxis() # y軸を上下ひっくり返したいとき map=ax.pcolor(data,cmap=\"seismic\") # 数値データからカラーデータを作成 cmapの値により配色変化 fig.colorbar(map, ax=ax) # カラーデータと軸データを使ってグラフデータ生成 plt.show() # 表示(生成されているグラフデータを画面表示) カラーマップ指定 カラーマップに用いる配色は，ax.pcolor()の引数cmapで指定している。\ncmap(カラーマップ)の一覧はこちら。いろいろと変えてみると楽しい 軸目盛りの間隔 x軸やy軸の目盛(tick)の間隔を変更したいときは，リストで指定する。以下は，0から9までの整数値を軸名に指定する場合の例。\nax.set_xticks([range(0,11,1)]) tick = [i for i in range(0, 5, 1)] ax.set_yticks(tick) 注) リストではなく，numpy配列でも良い\n棒グラフ plt.bar(x, y, width) x：x軸 y：y軸 width：横幅 2つの棒グラフを表示\nimport matplotlib.pyplot as plt import numpy as np height1 = [80, 65, 100, 42, 54] # y座標① height2 = [55, 100, 98, 30, 21] # y座標② left = np.arange(len(height1)) labels = ['Japanese', 'Math', 'Science', 'Social', 'English'] # 座標軸に表示する文字列 width = 0.3 plt.bar(left, height1, color='r', width=width, align='center') # 1つ目のデータを表示 plt.bar(left+width, height2, color='b', width=width, align='center') # 2つ目のデータを表示 plt.xticks(left+width/2, labels) # 指定した文字列を座標軸に表示 plt.show() 【参考】\n【Python】matplotlibで色んな種類の棒グラフを表示する方法 Pyplot(1) 棒グラフ matplotlib で棒グラフを描く グラフで矢印の表示 ax.annotate('', xy=point['end'], xytext=point['start'], arrowprops=dict(shrink=0, width=1, headwidth=8, headlength=10, connectionstyle='arc3', facecolor='gray', edgecolor='gray')) ※‘start’から’end’方向への矢印\n【引数】\ns：注釈文章の内容 xy：終点の位置 xytext：始点の位置（テキストの位置） arrowprops：始点と終点間を結ぶ矢印の設定 width：矢印の線の幅 headwith：矢印自体の横幅 headlength：矢印自体の長さ shrink：矢印を縮小する割合 etc. ※始点と終点の経路はconnectionstyleで制御できる\n**【参考】\n[Matplotlib] 注釈と矢印 matplotlibで矢印を描画したい! annotateを使おう! グラフ上での日本語表記 japanize_matplotlib を import すればOK!（※外部ライブラリをインストール必要あり）\npip install japanize-matplotlib import japanize_matplotlib これだけで日本語表記ができる！！\nstyle の変更と自作 plt.style.use('\u003cstyle name\u003e') でスタイルを変更できる。使用可能なスタイルは以下のコマンドで確認可\nplt.style.available デフォルトで付属しているスタイルは~/anaconda3/lib/python3.9/site-packages/matplotlib/mpl-data/stylelibにある。 自作する場合は~/.config/matplotlib/stylelibの下に.mplstyleファルを作成する mplstyleファイルの設定の仕方はこちらを参照\n参考 【Matplotlibの使い方】Matplotlibで作成したグラフをカッコ良くする方法 note.nkmk.me Matplotlib スタイルによるグラフの見た目の変更 Customizing Matplotlib with style sheets and rcParams ",
    "description": "",
    "tags": null,
    "title": "Matplotlib",
    "uri": "/watanuki/python/matplotlib/index.html"
  },
  {
    "content": "Jupyterの語源と読み方 もともと，プログラミング言語 Julia と Python と R を実行できる環境だったため Jupyter と名付けられたらしい。 ギリシャ神話の神様ユピテル(ジュピター)とかけてるのだと思うが，こちらの綴は Jupiter と1文字違う。\nJupyterのほうは，Python(パイソン)の読み方に合わせて国内では\"ジュパイター\"と読む人もいるが，開発者は\"ジュピター\"と呼んでいるようで，Youtubeにある英語でのjupyter関連の解説を聞いても大抵\"ジュピター\"に聞こえる。 セル 編集モードへの変更：ダブルクリックまたは\"Enter\" コマンドモードへの変更：ESC セルの内容の実行 Windows：Ctrl+Enter MacOS：command+Return OS共通：Shift+Enter Markdownセルとcodeセル Markdownセル：テキストを入力するためのセル Codeセル：Pythonの実行を行うセル arkdownセルの編集方法 “#“でタイトル “##“でサブタイトル “-“で箇条書き “太文字“で太文字 便利なショートカットキー（Window） コマンドモード ショートカットキー 説明 F 検索・置換 Ctrl -Shift Ctrl -Shift Enter 編集モードにする P コマンドパレットを開く Shift -Enter Ctrl -Enter Alt -Enter Y コードセルにする M マークダウンセルにする R rawセルにする 1 見出し１にする 2 見出し２にする 3 見出し３にする 4 見出し４にする 5 見出し５にする 6 見出し６にする K 上のセルを選択する Up 上のセルを選択する Down 下のセルを選択する J 下のセルを選択する Shift -K Shift -Up Shift -Down Shift -J A 上にセルを追加する B 下にセルを追加する X 選択しているセルをカット C 選択しているセルをコピー Shift -V V 下に貼り付け Z セルの削除をやり直す DD 選択しているセルを削除する Shift -M Ctrl -S S 保存する L 行番号の表示・非表示 O セルの出力結果の表示・非表示 Shift -O H キーボードショートカット表示 I×2 カーネルをインタラプト 0 カーネルを再起動 Esc ページャーを閉じる Q ページャーを閉じる Shift -L Shift -Space Space 下にスクロール 編集モード ショートカットキー 説明 Tab コード補完・タブ Shift-Tab ツールチップ Ctrl-] インデント Ctrl-[ ディデント Ctrl-A 全選択 Ctrl-Z やり直し Ctrl-Shift - Ctrl-Y やり直し Ctrl-Home セルの最初に移動 Ctrl-Up セルの最初に移動 Ctrl-End セルの最後に移動 Ctrl-Down セルの最後に移動 Ctrl-Left 一単語前に移動 Ctrl-Right 一単語後に移動 Ctrl-Backspace 前の単語を削除 Ctrl-Delete 後の単語を削除 Ctrl-M コマンドモードにする Ctrl-Shift-F コマンドパレットを開く Ctrl-Shift-P コマンドパレットを開く Esc コマンドモードにする Shift-Enter セルを実行し、下のセルを選択する Ctrl-Enter セルを実行する Alt-Enter セルを実行し、下にセルを追加する Ctrl-Shift-Minus セルを分割する Ctrl-S 保存する Down カーソルを下に移動 Up カーソルを上に移動 Ctrl-/ 選択部分をコメントアウト Kernel セルの左の “In[]” の括弧内の数字は実行を行った順番を示す。 順番によっては正常に作動しない場合もあるため最後は左上の欄から\"Kernel \u003e Restart \u0026 Run All\"をクリック ",
    "description": "",
    "tags": null,
    "title": "Jupyter notebook",
    "uri": "/watanuki/python/jupyter/index.html"
  },
  {
    "content": "基本演算 Cとおおむね同じ (演算子一覧は p.54, 71) ただし，++, --は使えない。+=, -=は使える 関数の定義 defで始まる行で関数名と引数を定義する 次行から関数の終わりまではインデントして命令文を書く 書式\ndef function_name(args): \"\"\"Docstring\"\"\" 命令文 #ここから関数の終わりまでインデントをする return result Docstring（ドックストリング） は　help(function_name) を実行したときに出力される文字列（function_name関数の説明文）のこと。一般的に関数名の直後に書き、三重引用符で囲む ただし，返り値は省略できる。 C言語と同様に引数を設定して呼び出せば実行できる。 print_name(\"Yamaguchi\",\"Daisuki\") My name is Daisuki Yamaguchi. 引数名をつけて，引数の値を指定することもできる。 print_name(family=\"Yamaguchi\",first=\"Daisuki\") My name is Daisuki Yamaguchi. 引数名をつければ，引数の順番はランダムでも良い print_name(first=\"Daisuki\",family=\"Yamaguchi\") My name is Daisuki Yamaguchi. 引数のデフォルト値, p.243 引数にデフォルト値を設定することもできる。\ndef print_name(family=\"Momo\",first=\"Taro\"): # family: 姓, first: 名 print(\"My name is {0} {1}.\".format(first, family)) デフォルト値の設定されている引数は，呼び出し時に省略可能。以下ではfamilyの方のみ省略している。\nprint_name(first=\"Daisuki\") 実行結果 My name is Daisuki Momo.\n複数の返り値をもつ関数 Pythonの関数では，返り値を複数指定できる。\ndef interval(mean,sd): # 平均mean, 標準偏差sdから，サンプルの約68%が含まれる区間を出力 return mean-sd, mean+sd 複数の返り値を，それぞれ別の変数で受け取ることができる。\nlow,high=interval(70,10) print(low,high) 実行結果 60 80 複数の返り値を，一つの変数でまとめて受け取ることもできる。\nret=interval(70,10) print(ret[0], ret[1]) print(type(ret)) ## 返り値の型はタプル(要素の書き換えを出来ないリスト。タプルの詳細については後述) ## ret[0]=3 # 返り値の要素を変更するとエラーが出る。(タプルの要素は書き換え不可。後述) 実行結果 60 80 \u003cclass ’tuple'\u003e print文 フォーマット指定その1: printf形式 print(“x=%d, y=%e” % (x, y))\nフォーマット指定方法その2: format method 今後おすすめの方法は，文字列に対するメソッドformat()を使う“format()メソッド”と呼ばれる方法。\n実行例 print(“x={0}, y={1}\".format(x, y)) # {}の中の数字で，format()の何番目の引数か指定 print(“x={}, y={}\".format(x, y)) # format()の引数順に表示するなら{}内の数字は省略可 print(“x={1}, y={0}\".format(x, y)) # {}内の数字を変えてみた print(“x={0:+d}, y={1:4.2f}\".format(x, y)) # 数値フォーマットの指定も可能 実行結果 x=9, y=False x=9, y=False x=False, y=9 x=+9, y=0.00 フォーマット指定方法その3: その他 他にもいろんな方法があって切りがない。。。\n実行例 x=5 print(f\"x={x}”) print(“x=\"+str(x)) 実行結果 x=5 x=5 if文 if文 p.96 x=1 if x == 0: print(x, \"is zero\") elif x \u003e 0: print(x, \"is positive\") else: print(x, \"is negative\") 注) pythonはC言語のように{}を使わない。インデント(空白4文字)で構文単位を表現\nif-elseを1行で書く p.110 1行if文の書式 : 返り値 if 条件式 else 返り値\n例えば，絶対値を求める関数absvalをdefを使って書くと以下のようになる。\ndef absval(x): if x\u003e0: absval=x else: absval=-x return absval この関数を1行にまとめて書くと，以下のようにとても簡潔になる。\ndef absval(x): return x if x\u003e0 else -x While文 while文, p.112 i = 0 while i \u003c 10: print(i, end=' ') i += 1 for文 for文の特徴\nPythonのデフォルト実装では、動的に解釈を行う（型が柔軟である)という言語の性質上、CやFortranなどのように効率的なマシンコードへのコンパイルができないという特徴を持つ。この弱点を克服するための手法として\nPyPyプロジェクト：PythonのJust-In-Time実装 Cythonプロジェクト：PythonコードをCコードに変換する Numbaプロジェクト：Pythonコードブロックを高速LLVMバイトコードに変換する などが知られているが、このどれもが標準CPythonエンジンほどには普及していない。このようなPythonの低速性はfor文などの小さな操作を大量に繰り返す状況で顕著になる。\nfor文の構造\nfor 変数 in イテラブル: 実行文 イテラブル: 順に一つずつ要素を取り出すことができるオブジェクト ex) リスト, range() でつくるシーケンスなど(後述) for と in の間の変数にイテラブルの要素が順に代入される リストを使う リストとはPythonに用意されている配列の一種で，要素を[]内に列挙する。要素の取り出しは，例えば以下のようにfor文で行える。 リストの詳細は今後の課題でも扱う。\nfor x in [1, 5, 9]: print(x, end=\" \") 実行結果 1 5 9 リストの要素を順に変数に代入することも簡単にできる。\nnumlist = [1, 5, 9] for i in numlist: print(i, end=\" \") 実行結果 1 5 9 range()関数を使う range(end): 0以上end未満の数列を生成する range(begin, end): begin以上end未満の数列を生成する。 range(begin, end, step): begin以上end未満の数列を生成する。stepは要素間の間隔 ",
    "description": "",
    "tags": null,
    "title": "Function",
    "uri": "/watanuki/python/function/index.html"
  },
  {
    "content": "filtfiltを用いたバンドパスフィルタ(バターワースフィルタ)の記述例 #バターワースフィルタ（バンドパス） fp = np.array([25, 50]) #通過域端周波数[Hz] fs = np.array([10, 100]) #阻止域端周波数[Hz] gpass = 3 #通過域端最大損失[dB] gstop = 40 #阻止域端最小損失[dB] def bandpass(x, samplerate, fp, fs, gpass, gstop):#samplerate がサンプリング周波数 fn = samplerate / 2 #ナイキスト周波数 wp = fp / fn #ナイキスト周波数で通過域端周波数を正規化 ws = fs / fn #ナイキスト周波数で阻止域端周波数を正規化 N, Wn = signal.buttord(wp, ws, gpass, gstop) #オーダーとバターワースの正規化周波数を計算 b, a = signal.butter(N, Wn, 'bandpass') #フィルタ伝達関数の分子と分母を計算 y = signal.filtfilt(b, a, x) #信号に対してフィルタをかける return y #フィルタ後の信号を返す y = bandpass(f_biceps, samplerate, fp, fs, gpass, gstop) scipy.signal.filtfilt scipyのfiltfiltを使用する場合は以下のようにインポートする\nfrom scipy import signal import matplotlib.pyplot as plt ※pltはインポートしなくても大丈夫？\n○filtfiltの記述の仕方 filtfiltでバターワースフィルターをかける場合には以下のように記述する\nb, a = signal.butter(8, 0.125) y = signal.filtfilt(b, a, x, padlen=150) ○filtfiltのパラメータと返り値 scipy.signal.filtfilt(b, a, x, axis=- 1, padtype='odd', padlen=None, method='pad', irlen=None)` parameters\nb : (N,)arrau_like フィルターの分子係数\na : (N,)array_like フィルターの分母係数\na[0]が1でなければaもbもa[0]で正規化される。\nx : array_like フィルターをかける配列のデータ\naxis : int, optional フィルターを適用するx軸。デフォルトは-1\npadtype\npandlen\nmethod\nirlen\nreturn\nndarray xと同じ形状の(?)フィルタリングされた出力 バターワースデジタルフィルター、バターワースアナログフィルターの設計 バターワースフィルターの設計ではscipy.signal.butterモジュールを使用する。 このモジュールでは N 次元のデジタル、またはアナログバターワースフィルターを設計し、係数を返す。\n○記述方法 from scipy import signal import matplotlib.pyplot as plt b, a = signal.butter(4, 100, 'low', analog=True) ○パラメータと返り値 scipy.signal.butter(N, Wn, btype='low', analog=False, output='ba', fs=None) parameters\nN : int フィルターの次数　←　buttorモジュールで必要な最低次数を求められる(？)\nWn : array_like 臨界周波数。\nローパス、ハイパスフィルターでは、Wn はスカラー。バンドパス、バンドストップフィルターでは長さ2の配列。\nバターワースフィルターでは、ゲインが通過帯域の1/√2 まで低下する点(「-3dB点」)を表す。\nアナログフィルターでは Wn は各周波数(例：rad/s)\nbtype : {‘lowpass’, ‘highpass’, ‘bandpass’, ‘bandstop’}, optional filterのタイプ。デフォルトはlowpass\nanalog\noutput\nfs\nReturns\nb, a : nadarray, ndarray IIR フィルターの分子 (b) および 分母 (a) 多項式。 output=‘ba’ のときだけ返される。\nz, p, k\nsos\nバターワースフィルターの次数選択 バターワースフィルターの次数選択では buttord モジュールを用いる。\nこのモジュールでは、通過帯域で gpass dB 以上の減衰がなく、停止帯域で gstop dB 以上の減衰がある最低次のデジタルまたはアナログバターワースフィルタの次数を返す。\n○記述方法 from scipy import signal import matplotlib.pyplot as pltN, Wn = signal.buttord([20, 50], [14, 60], 3, 40, True) b, a = signal.butter(N, Wn, 'band', True) w, h = signal.freqs(b, a, np.logspace(1, 2, 500)) ○パラメータと返り値 scipy.signal.buttord(wp, ws, gpass, gstop, analog=False, fs=None) parameters\nwp, ws : float 通過帯域と阻止帯域のエッジ周波数。\nデジタルフィルタの場合、これらはfsと同じ単位である。デフォルトでは、fsは 2 half-cycles/sample なので、これらは0から1に正規化され、1がナイキスト周波数となる。(wpとwsはhalf-cycles/sample )例えば\nローパス：wp=0.2, ws=0.3 ハイパス：wp = 0.3, ws = 0.2 バンドパス：wp = [0.2, 0.5]、ws = [0.1, 0.6]. バンドストップ：wp＝［0.1，0.6］，ws＝［0.2，0.5］。 アナログフィルタの場合、wpとwsは角周波数（例：rad/s）です。\ngpass : float 通過帯域の最大損失(dB)。\ngstop : float 停止帯域の最小減衰量（dB）。\nanalog : bool, optional\nfs : float, optional デジタルシステムのサンプリング周波数\nreturns\nord : int 使用を満たすバターワースフィルターの最低次数\nwn : ndarray or float バターワース固有振動数（すなわち “3dB振動数”）。フィルタリングの結果を得るために、butterと一緒に使用する必要がある。fs が指定された場合、これは同じ単位であり、fs も butter に渡さなければならない。\n参考 scipy.signal.filtfilt scipy.signal.butter scipy.signal.buttor ",
    "description": "",
    "tags": null,
    "title": "Filter with python",
    "uri": "/watanuki/python/filter/index.html"
  },
  {
    "content": "1. 辞書(dict)の特徴 名前 例 リスト(list) L=[\"kiwi\", \"banana\", \"apple\"] インデックス番号付き集合 タプル(tuple) T=(\"kiwi\", \"banana\", \"apple\") インデックス番号付き集合(代入不可) 辞書(dict) D={\"kiwi\":3, \"banana\":2, \"apple\":3} インデックス番号無し (key,value) 対応表 集合(set) S={\"kiwi\", \"banana\", \"apple\"} インデックス番号無し集合 書式: dict_name={key 1: value 1, key 2: value 2, ...} 辞書(dict)には，検索のためのkeyと，検索キーに紐付けられるvalueのペアを登録する。 各要素に対するインデックスは存在しない。 注意:\nPython 3.5以前 ではdictに対する要素の登録順序と，実際に保存されている順序と異なることがある。(順序非保存) Python 3.7以降 ではdictでも順序は保存(順序保存) Python 3.6では非公式に順序保存 2. dictの定義 reward={\"cheese\" : 100 , # リストや辞書等では，折返し記号\"\\\"なしで改行可 \"enemy\" : -10, \"friend\" : -1} print(reward) print(reward[\"friend\"]) # 辞書の参照は dict[key] Qvalue={(1,\"right\") : 0.5, (1,\"left\") : 1.5, (2,\"right\") : 0, (2, \"left\") : -1} print(Qvalue) print(Qvalue[(2,\"right\")]) 出力結果 {'cheese': 100, 'enemy': -10, 'friend': -1} -1 {(1, 'right'): 0.5, (1, 'left'): 1.5, (2, 'right'): 0, (2, 'left'): -1} 0 3. 辞書の更新・追加 dict[key]の使用 dict[key]=new_value\nkeyが辞書dictに存在しない　→　{key:new_value}のペアを登録 keyが辞書dictに存在する　→　keyに対応するvalueをnew_valueに変更 dict.setdefault()の使用 メソッドdict.setdefault(key,value)を使用する。\nkeyが辞書dictに存在しない場合　→　{key:value}ペアを登録する keyが辞書dictに存在する場合　→　変化なし 返り値はkeyに対するvalue（上記の処理後に返却) 4. 辞書の参照の仕方 dict[key] 直接辞書要素にアクセスする 存在しないキーに対してアクセスするとエラーになる dct.get(key) 存在しないキーに対してもエラーにならず、Noneが返り値になる dict.get(key,[default]) メソッドdict.get()は存在しないkeyにアクセスした場合に返す値(difault)を指定できる。 注）[]で囲んだ引数は、省略可能なことを示す。 5. 辞書の値一覧の返却 doct.keys() 辞書に含まれるすべてのkeyの一覧を返却する\ndict.values() 辞書に含まれるすべてのvalueの一覧を返却する\n6. 関数とMutableな引数 引数がImmutable(変更不可)　→　呼び出した側の引数（実引数）は変化しない int float str tuple 型など… 引数がMutable(変更可)　→　実引数も変化 list dict set 型など… ",
    "description": "",
    "tags": null,
    "title": "Dict",
    "uri": "/watanuki/python/dict/index.html"
  },
  {
    "content": "ライブラリの作成方法 directory に __init.py__ ファイルを作成 site-packages ディレクトリに作成したライブラリを追加する（シンボリックリンクでも可） site-packages の場所は $ python -m site で確認できる ディレクトリをパスに追加する場合は次の通り $ export PYTHONPATH=\"\u003cpath\u003e:$PYTHONPATH\" ",
    "description": "",
    "tags": null,
    "title": "Create Library",
    "uri": "/watanuki/python/create-library/index.html"
  },
  {
    "content": "クラス(class) 1. 用語(クラス, インスタンス，オブジェクト) クラス pythonにおける型のようなもの。予め定義されているものもあるが，ユーザが定義して使うこともできる。 例) int, float, list, tuple, dict 名簿を作るとき，住所や名前を書いてもらう様式(テンプレート)に該当 インスタンス (instance) クラス(型)から生成されるデータのこと。インスタンス・オブジェクトともいう intはクラス，1, 2, ..はインスタンス listはクラス, [1, 3]はインスタンス 名簿用テンプレートの空欄に，実際にデータを書いてもらった1枚1枚にインスタンスは対応 オブジェクト(object) 定義できるものはなんでもかんでもオブジェクト。。。 例) クラスもインスタンスもメソッドもオブジェクト。 2. クラスを作る キーワード 初期化メソッド 定義したクラスによりインスタンスを生成するときに実行される関数 インスタンス変数 クラス内の様々なメソッド(関数)で使うことができる変数。クラス内でのみ使える大域変数のようなもの。 大抵，初期化メソッドで生成・参照。 クラス内では， self.nameのように，必ずself.をつけて参照する(具体例は次のセルの問に) インスタンス化したオブジェクトからは，オブジェクト名.変数名 (taro.nameなど)で参照(具体例は次のセルの問に) インスタンス・メソッド クラス内で第一引数にselfを指定して定義する関数 クラス内ではself.関数名 で相互参照できる(引数からはselfは省略) インスタンス化したオブジェクトからは，オブジェクト名.関数名 で参照(呼び出し時に第一引数selfは省略) クラスの例 class Name_list: def __init__(self, family=\"Momo\", first=\"Taro\"): # 初期化メソッド(インスタンス生成時に実行) self.family = family # インスタンス変数 family の生成 self.first = first # インスタンス変数には\"self.\"をつける def print(self): # インスタンス・メソッド(第一引数は必ずself) print(\"My name is {} {}.\".format(self.first, self.family)) # インスタンス変数には\"self.\"をつけて参照 momo = Name_list() # インスタンスを生成し，変数momoに代入 dai = Name_list(family=\"Yamaguchi\", first=\"Daisuki\") # インスタンスを生成し，変数daiに代入 momo.print() # インスタンスmomoのメソッドprint()を実行 dai.print() # インスタンスdaiのメソッドprint()を実行 print(momo.family) # インスタンスmomoのインスタンス変数familyにアクセス 実行結果 My name is Taro Momo. My name is Daisuki Yamaguchi. Momo 3. クラスの継承 class Name_list: def __init__(self, family=\"Momo\",first=\"Taro\"): self.family = family self.first = first def print(self): print(\"My name is {} {}.\".format(self.first, self.family)) 上記クラスName_List(本シート初めの例と同じ)の改造版のクラスName_List_oskを定義し，インスタンス・メソッドprintの表示を日本語にしたかったとする。 このように，一部のインスタンス・メソッドの修正や追加のみをしたクラスを作成する場合，クラスの継承を用いると必要箇所のみの定義ですむ。\n5.1 スーパークラスの一部の関数を置き換える 以下の例では，初期化インスタンスはclass Name_listと同じものを使うため再定義はせず，print()の再定義のみしている。\nclass Name_list_osk(Name_list): # class Name_Listを継承したクラス Name_list_jpを定義 def print(self): print(\"{} {}っていいまんねん。\".format(self.family, self.first)) クラスAを継承してクラスBを定義した時，クラスAをスーパークラス，クラスBをサブクラス(もしくは派生クラス)と呼ぶ。上記の例では，Name_listがスーパークラス，Name_list_oskがサブクラスになる。親クラスと子クラスと呼ぶこともある。\n実行例 ```python momo = Name_list() # インスタンスを生成し，変数momoに代入 dai = Name_list_osk(family=\"山口\", first=\"大鋤\") # インスタンスを生成し，変数daiに代入 dai.print() 山口 大鋤っていいまんねん。 5.2 スーパークラスの関数を呼び出しつつ，さらに追加の処理も行う 以下は，クラスName_listを継承し，学籍番号もインスタンス変数にもつクラスNameID_listを定義した例。 super().__init__()を呼び出すことで，スーパークラスの初期化メソッドを実行するとともに，追加の処理も行っている。\nclass NameID_list(Name_list): def __init__(self, family=\"Momo\", first=\"Taro\", ID=\"000\"): super().__init__(family, first) # スーパークラス(Name_list)の初期化メソッドを呼び出す self.ID = ID def printID(self): print(\"ID:\" + self.ID) 実行例 スーパークラス(Name_list)の初期化メソッドも実行されているので，インスタンス変数family, firstへの値の代入もなされていることに注意。\ndai = NameID_list(family=\"Yamaguchi\", first=\"Daisuki\", ID=\"999\") # インスタンスを生成し，変数daiに代入 dai.printID() # NameID_listで追加したインスタンス関数の呼び出し dai.print() # Name_listのインスタンス関数を呼び出せる print(dai.family) # スーパークラスの初期化メソッドにより，インスタンス変数`family`に値が代入されている。 ID:999 My name is Daisuki Yamaguchi. Yamaguchi ",
    "description": "",
    "tags": null,
    "title": "Class",
    "uri": "/watanuki/python/class/index.html"
  },
  {
    "content": "pip のアップデート pip と setuptools のアップデート $ python -m pip install --upgrade pip setuptools ※-mはインターフェイスオプションで、pythonのモジュール（パッケージ）を実行するために使用\nパッケージのアップデート $ pip install -U \u003cpackage-name\u003e または\n$ pip install --upgrade \u003cpackage name\u003e naconda のアップデート すべてのパッケージをアップデート $ conda update --all 特定のパッケージのアップデート $ conda update \u003cpackage name1\u003e \u003cpackage name2\u003e anaconda 本体のアップデート $ conda update -n base -c defaults conda または\n$ conda update -n base conda ※上は(base)と作成した仮想環境両方アップデートされた…（下のコマンドは不明）\n※よく使うオプションは以下の通り\n-n は --name の略で、環境名の指定 -c は --channel の略で、デフォルトリポジトリだけでなくチャネルを追加で指定 参考 Anaconda パッケージ アップデート方法 pipでアップデートするときのコマンド pip update ",
    "description": "",
    "tags": null,
    "title": "Anaconda Update",
    "uri": "/watanuki/python/anaconda-update/index.html"
  },
  {
    "content": "タプル(tuple) Pythonにはデータの集合を扱うための様々なデータ型がある。\n以下は標準で用意されているもの。\n名前 例 リスト(list) L=[\"kiwi\", \"banana\", \"apple\"] インデックス番号付き集合 タプル(tuple) T=(\"kiwi\", \"banana\", \"apple\") インデックス番号付き集合(代入不可) 辞書(dict) D={\"kiwi\":3, \"banana\":2, \"apple\":3} インデックス番号無し (key,value) 対応表 集合(set) S={\"kiwi\", \"banana\", \"apple\"} インデックス番号無し集合 以下は拡張モジュールを利用するもの。\n名前 例 numpy.ndarray N=np.array([1,2,3]) 数値計算用の多次元配列 pandas.Series s=pd.Series([280,198],index=['tomato','banana']) 行に名前がある1次元配列 pandas.DataFrame df=pd.DataFrame([['tomato',280],['banana', 198]], columns=['name','price']) 列や行に名前がある2次元配列 タプルの特徴 タプルの定義，要素へのアクセス，スライス等はリストとほぼ同様 リストは要素を[]で囲むが，タプルは()で囲む リストと異なり，一度定義したら要素の書き換えはできない タプルの定義 fruits=(\"banana\", \"prange\", \"apple\") a, b, c = fruits#変数a,b,cへそれぞれ一括代入 L = tuple(range(5)) タプルへの代入 一度定義したタプルの要素を後で書き換えることはできない。\na=(1,2,3,5) a[3]=4 # 要素を書き換えようとするとエラーが出る(試してみること) ただし，以下のように変数に代入されているタプルを別のタプルに置き換えることはできる。\na=(1,2,3,5) a=(5,2,3) # タプルの置き換え (タプル(5,2,3)のidがaの参照先に) ",
    "description": "",
    "tags": null,
    "title": "Tuple",
    "uri": "/watanuki/python/tuple/index.html"
  },
  {
    "content": "Pythonの便利なモジュール モジュール・パッケージ・ライブラリの違い ライブラリ\nクラスや関数を記述したファイル(.py)\nパッケージ\nいくつかのモジュールを一つのディレクトリ（フォルダ）にまとめたもの\nライブラリ\nいくつかのパッケージをまとめたもの。モジュールやパッケージをライブラリと呼ぶことも、、、\npythonのライブラリ Numpy\nNumpyとはN次元配列(N-dimensional array, ndarray)を定義し、ベクトルや行列をはじめとする数値計算を行うためのモジュールである。\nC言語で記述されているため高速処理可能 Numpyモジュールで生成する配列の型名はnumpy.ndarray pandas\npandasはデータ解析を容易にするPythonのサードパーティライブラリです。 データ構造に対して様々な処理を施す機能を提供しており、他のライブラリをバックエンドとして利用して連携して動作できることやデータに対する豊富な処理機能を備えていることから、高度なデータ解析に欠かせないツールとなっている。NumpyのようにC言語による実装であるため配列演算の高速化が図られている点も大規模データの扱いを容易にする魅力の一つとなっている。\nmatplotlib\nグラフやそれ以外の2次元の形式で行うデータの可視化に用いるライブラリ。\n出版に適したグラフを作るのに非常に適しており、IPythonとうまく統合されているためIPythonとmatplotlibはデータのグラフ化や探索を容易に行えるインタラクティブな環境を提供している。 ウィンドウに表示されているツールバーからプロットの特定の領域をズームしたり、プロットで表示されれる範囲を変更することができる。\nIPython\nインタラクティブで探索的な計算を行うことができ、ロバスト性と生産性を持つ環境が提供される。 Pythonのシェルを拡張したもので、Pythonのコードの記述、テスト、デバッグを加速するように設計されている。特に、インタラクティブなデータ操作とmatplotlibによるデータの可視化に非常に便利。\n標準的なターミナル操作形式のIPythonシェル以外にも、次のようなものも提供している。\nWebブラウザを通じてIPythonと接続することができる、mathematica風のHTMLノートブック インラインのグラフ描画、複数行の編集、文法のハイライトが可能なQtフレームワークを用いたGUIコンソール 並列・分散コンピューティングをインタラクティブに行える基盤 Scipy\n科学計算の計算における様々な一般的な問題に取り組めるパッケージ群。\nscipy.integrate：数値積分ルーチンや微分方程式ソルバ scipy.linalg：線形代数ルーチンやnumpy.linalgで提供されている機能を拡張した行列の分解機能 scipy.optimaze：関数の最適化（最短化）と求根アルゴリズム scipy.signal：信号処理ツール scipy.sparse：疎（スパース）なデータを持つ行列や線形システムの解法 scipy.special：ガンマ関数のような多数の一般的な数学の関数を実装したFortanのライブラリSPECFUNを使うためのラッパー scipy.stats：標準的な連続分布や離散分布（密度関数、サンプラー、連続分布関数）、様々な統計検定、その他の記述統計 scipy.weave：配列計算の加速のために用いるインラインでのC++コードを利用するためのツール 標準モジュール モジュール名 記述法 概要 print print(“出力1”, “出力2”, sep=‘sep’, end=‘end’) 引数を出力する。sepには値の間に挿入される文字列（デフォルトはsep=’ ‘）、endには最後の値の後につかされる文字列（デフォルトはend=’\\n’）を指定 dir dir(オブジェクト名) オブジェクトのすべての属性（含まれる関数やメソッド等）を表示 type type(オブジェクト名) どのような型のオブジェクトであるかを確認できる。 sum sum(リスト) リスト要素の数値の合計を返却する input input(“文字列”) 文字列を出力し、キーボードからの入力を返却する max max(x,y,z,key=function) x,y,zの中で最も大きい値を返却する。key'に任意の関数f(x)を渡すと argmax f(x)‘を計算する（関数f(x), f(y), f(z) の計算結果が最大となる変数を返す) Jupyter notebook コマンド 記述法 概要 %timeit %timeit function() 指定した関数の実行時間を計算 NumPyライブラリ モジュール名 記述法 import 概要 arange np.arange(0, 20+step, step) numpy 0以上20+step未満の数値をstep刻みで生成 sin np.sin(time) numpy timeの各要素に対するsin関数の値をリスト化 mean np.mean(L) numpy Lの平均値を計算 std np.std(L) numpy Lの標準偏差を計算 PyPlot インターフェース 記述法 import 用途 plt.figure(figsize=(8.4)) matplotlib.pyplot figureオブジェクトの生成、figsuzeは省略可能 plt.plot(x, y, label=“y=x”) matplotlib.pyplot x軸y軸データを指定しプロット。labelは省略可能 plt.xlabel(“time[s]”) matplotlib.pyplot pltにx軸ラベルを追加 plt.legend(loc=“upper right”) matplotlib.pyplot plt似凡例(plot()の引数に指定したlabel)を追加 plt.show matplotlib.pyplot グラフオブジェクトpltの描画 オブジェクト指向インターフェース 記述法 import 用途 ax1 = fig.add_subplot(211) — figの中に座標(Axes)オブジェクト生成。2行1列に配置した1番目とするオブジェクトの生成が1つだけの場合はaxとする。 ax1.plot(time, sint, label=“sin t”) — ax1にsin関数の折れ線グラフ(Primitives)登録(labelは省略可) ax1.legend(loc=“upper right”) — plot()で指定したlabelを右上に配置 ax1.set_xlabel(“t [s]”) — x軸ラベルの挿入 ax1.grid(True) — 格子を描く ax1.set_xlim(0, 20) — 描画範囲の指定 plt.tight_layout() — タイトルやラベルが重ならないように配置調整し、Figureオブジェクトを描画 plt.savefig(’triangular.png’) — グラフを保存したい場合。拡張子に応じてpng,jpg,pdf等の出力可能 plt.show() — 画像の出力。Jupyter Notebookの場合は省略可能 Pandasライブラリ モジュール名 記述法 概要 timeit %timeit df.at[‘y’, ‘b’] df.at[‘x’, ‘a’]の実行速度を出力 idxmin() df.idxmin() 最小値を持つ場所を示すインデックスを返す idxmax() df.idxmax() 最大値を持つ場所を示すインデックスを返す agg df.groupby([‘country’]).price.agg([len, min, max]) 列ごとに異なる関数を使って集約したい場合や複数の関数を同時に使って集約できる。len, min, maxの３つの記述統計量について集約を行っている 便利な関数 関数名 実行例 実行結果 概要 type() print(type(x)) \u003cclass ‘int’\u003e xの型名を返却する - - - - - - - - - - - - - - - - ※mathモジュール、randomモジュールに関しては下記参照\n便利な書き方 実行例 print(type(x) is bool) print(type(x) is not bool)\n実行結果 False True\n実行例\nモジュールのいろいろな読み込み方法, p.81 import \u003cmodule\u003e import \u003cmodule\u003e as \u003calias\u003e ## モジュールに省略名をつける。最もよく使われる(多分) from \u003cmodule\u003e import \u003cfunction\u003e ## 関数呼び出し時にモジュール名不要にする (多用しないこと。同名関数が異なるモジュールにあるときトラブルのもと) 例)\nimport math print(math.cos(0)) import math as ma print(ma.cos(0)) from math import cos print(cos(0)) math モジュール p.78 mathモジュールを読み込むと，いろいろな数学関数や定数を使える(一覧p.80-81)\n次のセルは，math モジュールの読み込みと関数実行の例。\nimport math ## mathモジュールの読み込み x=math.pi/2 math.sin(x) 実行結果 1.0 モジュール内の関数呼び出し モジュール名に続けて関数名を書く。mathモジュールにあるsin()関数ならば次のように書く。\nmath.sin() マニュアル等での表記も同様に書くのが一般。\nmathモジュールの関数や定数 数学関数の例 math.sin() math.cos() math.log() 定数の例 math.pi math.e ライブラリやモジュール, 関数についての詳細を知りたいときには以下のようにhelp()を使う\nhelp(math) help(math.sin) 注意: jupyter notebook上で一度importしたライブラリやモジュールは他のセルでも使える。複数のセルで同じモジュールを何度もimportする必要はない。\nrandom モジュール p.82 関数例\nrandom.randint(min,max) ## randomモジュールのrandint()関数 random.random() 実行例\nimport random x=random.random() print(x) ramdint(a,b)：a以上b以下の値をランダムに生成 random()：0以上1未満の値をランダムに生成 ",
    "description": "",
    "tags": null,
    "title": "python",
    "uri": "/watanuki/python/module/index.html"
  },
  {
    "content": "hugoでプロジェクトを作成 $ hugo new site \u003cプロジェクト名\u003e Congratulations! Your new Hugo site is created in PATH/hugo/test. Just a few more steps and you're ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \"hugo new theme \u003cTHEMENAME\u003e\" command. 2. Perhaps you want to add some content. You can add single files with \"hugo new \u003cSECTIONNAME\u003e/\u003cFILENAME\u003e.\u003cFORMAT\u003e\". 3. Start the built-in live server via \"hugo server\". プロジェクトを作成すると次のようなファイルが作成される\n$ tree \u003cdirectory name\u003e/ -L 1 \u003cdirectory name\u003e/ ├── archetypes ├── config.toml ├── content ├── data ├── layouts ├── public ├── resources ├── static └── themes ページの設定はconfig.tomlから変更できる。\nテーマは公式ページからダウンロードし使用する。 テーマの変更や言語設定などもconfig.tomlから行う。\n$ cat web-blog/config.toml baseURL = 'https://...' # ページを公開するドメイン名 languageCode = 'en-us' # 日本語ならja-jp title = \"\u003cblog name\u003e\" theme = \"kraiklyn\" # ダウンロードしたテーマ homeの作成 $ hugo new --kind home _index.md 章の作成 $ hugo new --kind chapter \u003cchapter name\u003e/_index.md 次のような内容が書かれた\u003cchapter\u003e/_index.mdが生成されるため、\n+++ archetype = \"chapter\" title = \"{{ replace .Name \"-\" \" \" | title }}\" weight = X +++ Lorem Ipsum. Xの部分を数字に置き換える。メニューはその順番で表示される。\n記事の作成 $ hugo new posts/test.md このコマンドを実行するとcontents/posts/test.mdが作成される。\nlocalで表示 また、次のコマンドを実行するとlocalhost:1313でプレビューが見れるようになる。\n$ hugo server -D webサイトの構築 次のコマンドを実行でpublicフォルダに静的ファイルが作成される。\n$ hugo thema Hugo Relearn Theme Hugo Learn Theme TinyWorks Kraiklyn 参考 HUGOの使い方 静的サイトジェネレータ「Hugo」と技術文書公開向けテーマ「Docsy」でOSSサイトを作る Hugo Relearn Theme \u003e Content ",
    "description": "",
    "tags": null,
    "title": "hugo note",
    "uri": "/watanuki/post/hugo-note/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Categories",
    "uri": "/watanuki/categories/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tags",
    "uri": "/watanuki/tags/index.html"
  }
]
